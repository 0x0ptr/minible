[1mdiff --git a/source_code/main_mcu/.vs/mini_ble/v14/.atsuo b/source_code/main_mcu/.vs/mini_ble/v14/.atsuo[m
[1mindex 9e2cb02..47c66c9 100644[m
Binary files a/source_code/main_mcu/.vs/mini_ble/v14/.atsuo and b/source_code/main_mcu/.vs/mini_ble/v14/.atsuo differ
[1mdiff --git a/source_code/main_mcu/src/COMMS/comms_aux_mcu.c b/source_code/main_mcu/src/COMMS/comms_aux_mcu.c[m
[1mindex db4d93d..c50a837 100644[m
[1m--- a/source_code/main_mcu/src/COMMS/comms_aux_mcu.c[m
[1m+++ b/source_code/main_mcu/src/COMMS/comms_aux_mcu.c[m
[36m@@ -71,6 +71,41 @@[m [mvoid comms_aux_mcu_send_simple_command_message(uint16_t command)[m
     comms_aux_mcu_wait_for_message_sent();    [m
 }[m
 [m
[32m+[m[32m/*! \fn     comms_aux_mcu_get_ble_chip_id(void)[m
[32m+[m[32m*   \brief  Get ATBTLC1000 chip ID[m
[32m+[m[32m*   \return uint32_t of chipID[m
[32m+[m[32m*   \note   BLE must be enabled before calling this[m
[32m+[m[32m*/[m
[32m+[m[32muint32_t comms_aux_mcu_get_ble_chip_id(void)[m
[32m+[m[32m{[m
[32m+[m[32m    aux_mcu_message_t* temp_rx_message;[m
[32m+[m[32m    uint32_t return_val;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Prepare status message request */[m
[32m+[m[32m    comms_aux_mcu_wait_for_message_sent();[m
[32m+[m[32m    aux_mcu_message_t* temp_tx_message_pt = comms_aux_mcu_get_temp_tx_message_object_pt();[m
[32m+[m[32m    memset((void*)temp_tx_message_pt, 0, sizeof(*temp_tx_message_pt));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Fill the correct fields */[m
[32m+[m[32m    temp_tx_message_pt->message_type = AUX_MCU_MSG_TYPE_PLAT_DETAILS;[m
[32m+[m[32m    temp_tx_message_pt->tx_reply_request_flag = 0x0001;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Send message */[m
[32m+[m[32m    dma_aux_mcu_init_tx_transfer((void*)&AUXMCU_SERCOM->USART.DATA.reg, (void*)temp_tx_message_pt, sizeof(*temp_tx_message_pt));[m
[32m+[m[32m    comms_aux_mcu_wait_for_message_sent();[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for message from aux MCU */[m
[32m+[m[32m    while(comms_aux_mcu_active_wait(&temp_rx_message) == RETURN_NOK){}[m
[32m+[m[41m    [m
[32m+[m[32m    /* Output debug info */[m
[32m+[m[32m    return_val = temp_rx_message->aux_details_message.atbtlc_chip_id;[m
[32m+[m
[32m+[m[32m    /* Info printed, rearm DMA RX */[m
[32m+[m[32m    comms_aux_arm_rx_and_clear_no_comms();[m
[32m+[m[41m    [m
[32m+[m[32m    return return_val;[m
[32m+[m[32m}[m
[32m+[m
 /*! \fn     comms_aux_mcu_send_receive_ping(void)[m
 *   \brief  Try to ping the aux MCU[m
 *   \return Success or not[m
[1mdiff --git a/source_code/main_mcu/src/COMMS/comms_aux_mcu.h b/source_code/main_mcu/src/COMMS/comms_aux_mcu.h[m
[1mindex 8c202fb..5d1a863 100644[m
[1m--- a/source_code/main_mcu/src/COMMS/comms_aux_mcu.h[m
[1m+++ b/source_code/main_mcu/src/COMMS/comms_aux_mcu.h[m
[36m@@ -26,6 +26,7 @@[m
 #define MAIN_MCU_COMMAND_SLEEP          0x0001[m
 #define MAIN_MCU_COMMAND_ATTACH_USB     0x0002[m
 #define MAIN_MCU_COMMAND_PING           0x0003[m
[32m+[m[32m#define MAIN_MCU_COMMAND_ENABLE_BLE     0x0004[m
 [m
 /* Typedefs */[m
 typedef struct[m
[36m@@ -79,6 +80,7 @@[m [mvoid comms_aux_mcu_send_message(aux_mcu_message_t* message);[m
 RET_TYPE comms_aux_mcu_send_receive_ping(void);[m
 void comms_aux_mcu_wait_for_message_sent(void);[m
 void comms_aux_arm_rx_and_clear_no_comms(void);[m
[32m+[m[32muint32_t comms_aux_mcu_get_ble_chip_id(void);[m
 void comms_aux_mcu_routine(void);[m
 [m
 [m
[1mdiff --git a/source_code/main_mcu/src/FILESYSTEM/custom_fs.c b/source_code/main_mcu/src/FILESYSTEM/custom_fs.c[m
[1mindex 4fe8c3c..9a229ee 100644[m
[1m--- a/source_code/main_mcu/src/FILESYSTEM/custom_fs.c[m
[1m+++ b/source_code/main_mcu/src/FILESYSTEM/custom_fs.c[m
[36m@@ -497,6 +497,22 @@[m [mvoid custom_fs_settings_clear_fw_upgrade_flag(void)[m
     return;    [m
 }[m
 [m
[32m+[m[32m/*! \fn     custom_fs_is_first_boot(void)[m
[32m+[m[32m*   \brief  Check for first boot[m
[32m+[m[32m*   \return TRUE for first boot[m
[32m+[m[32m*/[m
[32m+[m[32mBOOL custom_fs_is_first_boot(void)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((custom_fs_platform_settings_p != 0) && (custom_fs_platform_settings_p->first_boot_flag == 0xFFFF))[m
[32m+[m[32m    {[m
[32m+[m[32m        return TRUE;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        return FALSE;[m
[32m+[m[32m    }[m[41m    [m
[32m+[m[32m}[m
[32m+[m
 /*! \fn     custom_fs_settings_check_fw_upgrade_flag(void)[m
 *   \brief  Check for fw upgrade flag inside our settings[m
 *   \return The boolean[m
[1mdiff --git a/source_code/main_mcu/src/FILESYSTEM/custom_fs.h b/source_code/main_mcu/src/FILESYSTEM/custom_fs.h[m
[1mindex 02c4585..7b39a76 100644[m
[1m--- a/source_code/main_mcu/src/FILESYSTEM/custom_fs.h[m
[1m+++ b/source_code/main_mcu/src/FILESYSTEM/custom_fs.h[m
[36m@@ -73,7 +73,8 @@[m [mtypedef struct[m
 // Platform settings[m
 typedef struct  [m
 {[m
[31m-    uint8_t reserved[252];[m
[32m+[m[32m    uint8_t reserved[250];[m
[32m+[m[32m    uint16_t first_boot_flag;[m
     uint32_t start_upgrade_flag;[m
 } custom_platform_settings_t;[m
 [m
[36m@@ -144,6 +145,7 @@[m [mBOOL custom_fs_settings_check_fw_upgrade_flag(void);[m
 void custom_fs_settings_clear_fw_upgrade_flag(void);[m
 void custom_fs_settings_set_fw_upgrade_flag(void);[m
 uint32_t custom_fs_get_number_of_languages(void);[m
[32m+[m[32mBOOL custom_fs_is_first_boot(void);[m
 ret_type_te custom_fs_init(void);[m
 [m
 /* Global vars, for debug only */[m
[1mdiff --git a/source_code/main_mcu/src/debug.c b/source_code/main_mcu/src/debug.c[m
[1mindex ddfb970..ab86303 100644[m
[1m--- a/source_code/main_mcu/src/debug.c[m
[1m+++ b/source_code/main_mcu/src/debug.c[m
[36m@@ -494,7 +494,16 @@[m [mvoid debug_mcu_and_aux_info(void)[m
 */[m
 void debug_atbtlc_info(void)[m
 {	[m
[31m-    aux_mcu_message_t* temp_rx_message;[m
[32m+[m[32m    aux_mcu_message_t* temp_rx_message;[m[41m   [m
[32m+[m[41m    [m
[32m+[m[32m    /* Enable BLE */[m
[32m+[m[32m    platform_io_enable_ble();[m
[32m+[m[32m    comms_aux_mcu_send_simple_command_message(MAIN_MCU_COMMAND_ENABLE_BLE);[m
[32m+[m[41m    [m
[32m+[m[32m    /* wait for BLE to bootup */[m
[32m+[m[32m    comms_aux_mcu_wait_for_message_sent();[m
[32m+[m[32m    timer_delay_ms(10000);[m
[32m+[m[32m    while(comms_aux_mcu_active_wait(&temp_rx_message) == RETURN_NOK){}[m
     [m
     /* Prepare status message request */[m
     comms_aux_mcu_wait_for_message_sent();[m
[1mdiff --git a/source_code/main_mcu/src/main.c b/source_code/main_mcu/src/main.c[m
[1mindex 41324b3..e9cca70 100644[m
[1m--- a/source_code/main_mcu/src/main.c[m
[1m+++ b/source_code/main_mcu/src/main.c[m
[36m@@ -173,6 +173,12 @@[m [mvoid main_platform_init(void)[m
     {[m
         comms_aux_mcu_send_simple_command_message(MAIN_MCU_COMMAND_ATTACH_USB);[m
     }[m
[32m+[m[41m    [m
[32m+[m[32m    /* Check for first boot, perform functional testing */[m
[32m+[m[32m    if (custom_fs_is_first_boot() == FALSE)[m
[32m+[m[32m    {[m
[32m+[m[32m        sh1122_put_error_string(&plat_oled_descriptor, u"First Boot Tests...");[m
[32m+[m[32m    }[m
 }[m
 [m
 /*! \fn     main_standby_sleep(void)[m
