
aux_mcu.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .start_app_function_addr 00000034  00000200  00000200  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .flash_start_addr 00000008  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .ARM.attributes 00000028  00000000  00000000  000200d4  2**0
                  CONTENTS, READONLY
  3 .comment      00000059  00000000  00000000  000200fc  2**0
                  CONTENTS, READONLY
  4 .text         00001a7c  00002000  00002000  00012000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .relocate     000000d4  20000000  00003a7c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001064  200000e0  00003b60  000200e0  2**4
                  ALLOC
  7 .stack        00002004  20001144  00004bc4  000200e0  2**0
                  ALLOC
  8 .debug_info   00022c14  00000000  00000000  00020155  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000026bd  00000000  00000000  00042d69  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001ccc  00000000  00000000  00045426  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000360  00000000  00000000  000470f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000330  00000000  00000000  00047452  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000174e1  00000000  00000000  00047782  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000091c0  00000000  00000000  0005ec63  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00080bbd  00000000  00000000  00067e23  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00000764  00000000  00000000  000e89e0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .start_app_function_addr:

00000200 <jump_to_application_function>:
/* What I don't understand: why the "+1" in the second array element        */
/****************************************************************************/
const uint32_t jump_to_application_function_addr[2] __attribute__((used,section (".flash_start_addr"))) = {HMCRAMC0_ADDR+100,0x200+1};
void jump_to_application_function(void) __attribute__((used,section (".start_app_function_addr")));
void jump_to_application_function(void)
{
 200:	b580      	push	{r7, lr}
 202:	af00      	add	r7, sp, #0
    /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
    NVMCTRL->CTRLB.bit.MANW = 1;
 204:	4a08      	ldr	r2, [pc, #32]	; (228 <jump_to_application_function+0x28>)
 206:	6853      	ldr	r3, [r2, #4]
 208:	2180      	movs	r1, #128	; 0x80
 20a:	430b      	orrs	r3, r1
 20c:	6053      	str	r3, [r2, #4]
    
    /* Pointer to the Application Section */
    void (*application_code_entry)(void);
    
    /* Rebase the Stack Pointer */
    __set_MSP(*(uint32_t*)APP_START_ADDR);
 20e:	2380      	movs	r3, #128	; 0x80
 210:	019b      	lsls	r3, r3, #6

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 212:	681a      	ldr	r2, [r3, #0]
 214:	f382 8808 	msr	MSP, r2
    
    /* Rebase the vector table base address */
    SCB->VTOR = ((uint32_t)APP_START_ADDR & SCB_VTOR_TBLOFF_Msk);
 218:	4a04      	ldr	r2, [pc, #16]	; (22c <jump_to_application_function+0x2c>)
 21a:	6093      	str	r3, [r2, #8]
    
    /* Load the Reset Handler address of the application */
    application_code_entry = (void (*)(void))(unsigned *)(*(unsigned *)(APP_START_ADDR + 4));
 21c:	4b04      	ldr	r3, [pc, #16]	; (230 <jump_to_application_function+0x30>)
    
    /* Jump to user Reset Handler in the application */
    application_code_entry();
 21e:	681b      	ldr	r3, [r3, #0]
 220:	4798      	blx	r3
}
 222:	46bd      	mov	sp, r7
 224:	bd80      	pop	{r7, pc}
 226:	46c0      	nop			; (mov r8, r8)
 228:	41004000 	.word	0x41004000
 22c:	e000ed00 	.word	0xe000ed00
 230:	00002004 	.word	0x00002004

Disassembly of section .text:

00002000 <exception_table>:
    2000:	20003148 00003715 00003711 00003711     H1. .7...7...7..
	...
    202c:	00003711 00000000 00000000 00003711     .7...........7..
    203c:	00003711 00003711 00003711 00003711     .7...7...7...7..
    204c:	00003711 00003711 00003711 00002849     .7...7...7..I(..
    205c:	00003135 00003711 00003711 00003711     51...7...7...7..
    206c:	00003711 00003711 00000000 00000000     .7...7..........
    207c:	00002c89 00003711 00003711 00003711     .,...7...7...7..
    208c:	00003711 00003711 00000000 00000000     .7...7..........
    209c:	00003711 00003711 00003711 00003711     .7...7...7...7..
    20ac:	00003711 00000000                       .7......

000020b4 <__do_global_dtors_aux>:
    20b4:	b510      	push	{r4, lr}
    20b6:	4c06      	ldr	r4, [pc, #24]	; (20d0 <__do_global_dtors_aux+0x1c>)
    20b8:	7823      	ldrb	r3, [r4, #0]
    20ba:	2b00      	cmp	r3, #0
    20bc:	d107      	bne.n	20ce <__do_global_dtors_aux+0x1a>
    20be:	4b05      	ldr	r3, [pc, #20]	; (20d4 <__do_global_dtors_aux+0x20>)
    20c0:	2b00      	cmp	r3, #0
    20c2:	d002      	beq.n	20ca <__do_global_dtors_aux+0x16>
    20c4:	4804      	ldr	r0, [pc, #16]	; (20d8 <__do_global_dtors_aux+0x24>)
    20c6:	e000      	b.n	20ca <__do_global_dtors_aux+0x16>
    20c8:	bf00      	nop
    20ca:	2301      	movs	r3, #1
    20cc:	7023      	strb	r3, [r4, #0]
    20ce:	bd10      	pop	{r4, pc}
    20d0:	200000e0 	.word	0x200000e0
    20d4:	00000000 	.word	0x00000000
    20d8:	00003a7c 	.word	0x00003a7c

000020dc <frame_dummy>:
    20dc:	4b08      	ldr	r3, [pc, #32]	; (2100 <frame_dummy+0x24>)
    20de:	b510      	push	{r4, lr}
    20e0:	2b00      	cmp	r3, #0
    20e2:	d003      	beq.n	20ec <frame_dummy+0x10>
    20e4:	4907      	ldr	r1, [pc, #28]	; (2104 <frame_dummy+0x28>)
    20e6:	4808      	ldr	r0, [pc, #32]	; (2108 <frame_dummy+0x2c>)
    20e8:	e000      	b.n	20ec <frame_dummy+0x10>
    20ea:	bf00      	nop
    20ec:	4807      	ldr	r0, [pc, #28]	; (210c <frame_dummy+0x30>)
    20ee:	6803      	ldr	r3, [r0, #0]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d100      	bne.n	20f6 <frame_dummy+0x1a>
    20f4:	bd10      	pop	{r4, pc}
    20f6:	4b06      	ldr	r3, [pc, #24]	; (2110 <frame_dummy+0x34>)
    20f8:	2b00      	cmp	r3, #0
    20fa:	d0fb      	beq.n	20f4 <frame_dummy+0x18>
    20fc:	4798      	blx	r3
    20fe:	e7f9      	b.n	20f4 <frame_dummy+0x18>
    2100:	00000000 	.word	0x00000000
    2104:	200000e4 	.word	0x200000e4
    2108:	00003a7c 	.word	0x00003a7c
    210c:	00003a7c 	.word	0x00003a7c
    2110:	00000000 	.word	0x00000000

00002114 <clocks_map_gclk_to_peripheral_clock>:
void clocks_map_gclk_to_peripheral_clock(uint32_t gclk_id, uint32_t peripheral_clk_id)
{
    GCLK_CLKCTRL_Type clkctrl;                                          // Clkctrl struct
    clkctrl.reg = 0;                                                    // Reset temp var
    clkctrl.bit.ID = peripheral_clk_id;                                 // Select TCC0 input
    clkctrl.bit.GEN = gclk_id;                                          // Select gclk
    2114:	230f      	movs	r3, #15
    2116:	4018      	ands	r0, r3
    2118:	0200      	lsls	r0, r0, #8
    211a:	3330      	adds	r3, #48	; 0x30
    211c:	4019      	ands	r1, r3
    211e:	4301      	orrs	r1, r0
    clkctrl.bit.CLKEN = 1;                                              // Enable generator
    2120:	2080      	movs	r0, #128	; 0x80
    2122:	01c0      	lsls	r0, r0, #7
    2124:	4301      	orrs	r1, r0
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);             // Wait for sync
    2126:	4a04      	ldr	r2, [pc, #16]	; (2138 <clocks_map_gclk_to_peripheral_clock+0x24>)
    2128:	7853      	ldrb	r3, [r2, #1]
    212a:	b25b      	sxtb	r3, r3
    212c:	2b00      	cmp	r3, #0
    212e:	dbfb      	blt.n	2128 <clocks_map_gclk_to_peripheral_clock+0x14>
    GCLK->CLKCTRL = clkctrl;                                            // Write register
    2130:	4b01      	ldr	r3, [pc, #4]	; (2138 <clocks_map_gclk_to_peripheral_clock+0x24>)
    2132:	8059      	strh	r1, [r3, #2]
}
    2134:	4770      	bx	lr
    2136:	46c0      	nop			; (mov r8, r8)
    2138:	40000c00 	.word	0x40000c00

0000213c <clocks_start_48MDFLL>:
void clocks_start_48MDFLL(void)
{
    GCLK_GENCTRL_Type genctrl;                                  // Genctrl struct
    
    /* Set 1 wait states for on-board flash: from NVM characteristics */
    NVMCTRL->CTRLB.bit.RWS = 1;
    213c:	4a25      	ldr	r2, [pc, #148]	; (21d4 <clocks_start_48MDFLL+0x98>)
    213e:	6853      	ldr	r3, [r2, #4]
    2140:	211e      	movs	r1, #30
    2142:	438b      	bics	r3, r1
    2144:	391c      	subs	r1, #28
    2146:	430b      	orrs	r3, r1
    2148:	6053      	str	r3, [r2, #4]
    
    /* Reset GCLK module */
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);     // Wait for sync
    214a:	4a23      	ldr	r2, [pc, #140]	; (21d8 <clocks_start_48MDFLL+0x9c>)
    214c:	7853      	ldrb	r3, [r2, #1]
    214e:	b25b      	sxtb	r3, r3
    2150:	2b00      	cmp	r3, #0
    2152:	dbfb      	blt.n	214c <clocks_start_48MDFLL+0x10>
    GCLK->CTRL.reg = GCLK_CTRL_SWRST;                           // Trigger reset
    2154:	2201      	movs	r2, #1
    2156:	4b20      	ldr	r3, [pc, #128]	; (21d8 <clocks_start_48MDFLL+0x9c>)
    2158:	701a      	strb	r2, [r3, #0]
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);     // Wait for sync
    215a:	001a      	movs	r2, r3
    215c:	7853      	ldrb	r3, [r2, #1]
    215e:	b25b      	sxtb	r3, r3
    2160:	2b00      	cmp	r3, #0
    2162:	dbfb      	blt.n	215c <clocks_start_48MDFLL+0x20>
    while ((GCLK->CTRL.reg & GCLK_CTRL_SWRST) != 0);            // Wait for end of reset
    2164:	491c      	ldr	r1, [pc, #112]	; (21d8 <clocks_start_48MDFLL+0x9c>)
    2166:	2201      	movs	r2, #1
    2168:	780b      	ldrb	r3, [r1, #0]
    216a:	4213      	tst	r3, r2
    216c:	d1fc      	bne.n	2168 <clocks_start_48MDFLL+0x2c>
    
    /* Remove osc8m clock division */
    SYSCTRL_OSC8M_Type osc8m_register = SYSCTRL->OSC8M;         // load current osc8m register val
    216e:	491b      	ldr	r1, [pc, #108]	; (21dc <clocks_start_48MDFLL+0xa0>)
    2170:	6a0b      	ldr	r3, [r1, #32]
    osc8m_register.bit.FRANGE = SYSCTRL_OSC8M_FRANGE_2_Val;     // select 8mhz oscillation range
    osc8m_register.bit.PRESC = SYSCTRL_OSC8M_PRESC_0_Val;       // set 1 prescaler
    osc8m_register.bit.RUNSTDBY = 0;                            // oscillator not running during standby
    //osc8m_register.bit.ENABLE = 1;                              // enable oscillator (not needed as already enabled)
    SYSCTRL->OSC8M = osc8m_register;                            // write register
    2172:	2240      	movs	r2, #64	; 0x40
    2174:	4393      	bics	r3, r2
    2176:	4a1a      	ldr	r2, [pc, #104]	; (21e0 <clocks_start_48MDFLL+0xa4>)
    2178:	4013      	ands	r3, r2
    217a:	009b      	lsls	r3, r3, #2
    217c:	089b      	lsrs	r3, r3, #2
    217e:	2280      	movs	r2, #128	; 0x80
    2180:	0612      	lsls	r2, r2, #24
    2182:	4313      	orrs	r3, r2
    2184:	620b      	str	r3, [r1, #32]
    /************************************/
    /*  Configure DFLL48M in open loop  */
    /************************************/
    
    /* Disable ONDEMAND mode while writing configurations */
    while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY));    // Wait for sync
    2186:	2210      	movs	r2, #16
    2188:	68cb      	ldr	r3, [r1, #12]
    218a:	421a      	tst	r2, r3
    218c:	d0fc      	beq.n	2188 <clocks_start_48MDFLL+0x4c>
    SYSCTRL->DFLLCTRL.reg = 0;                                  // Disable ONDEMAND mode while writing configurations
    218e:	4913      	ldr	r1, [pc, #76]	; (21dc <clocks_start_48MDFLL+0xa0>)
    2190:	2300      	movs	r3, #0
    2192:	848b      	strh	r3, [r1, #36]	; 0x24
    
    /* Load coarse and fine values from NVM and store them in DFFLVAL.COARSE & DFFLVAL.FINE */
    uint32_t coarse_val = ((*((uint32_t *)SYSCTRL_FUSES_DFLL48M_COARSE_CAL_ADDR)) & SYSCTRL_FUSES_DFLL48M_COARSE_CAL_Msk) >> SYSCTRL_FUSES_DFLL48M_COARSE_CAL_Pos;
    2194:	4b13      	ldr	r3, [pc, #76]	; (21e4 <clocks_start_48MDFLL+0xa8>)
    2196:	681a      	ldr	r2, [r3, #0]
    uint32_t fine_val =  ((*((uint32_t *)FUSES_DFLL48M_FINE_CAL_ADDR)) & FUSES_DFLL48M_FINE_CAL_Msk) >> FUSES_DFLL48M_FINE_CAL_Pos;
    2198:	4b13      	ldr	r3, [pc, #76]	; (21e8 <clocks_start_48MDFLL+0xac>)
    219a:	681b      	ldr	r3, [r3, #0]
    SYSCTRL_DFLLVAL_Type dfll_val;                              // DFLL value register
    dfll_val.bit.COARSE = coarse_val;                           // Store coarse value
    dfll_val.bit.FINE = fine_val;                               // Store fine value
    SYSCTRL->DFLLVAL = dfll_val;                                // Store register value, no need for sync
    219c:	059b      	lsls	r3, r3, #22
    219e:	0e92      	lsrs	r2, r2, #26
    21a0:	0292      	lsls	r2, r2, #10
    21a2:	0d9b      	lsrs	r3, r3, #22
    21a4:	4313      	orrs	r3, r2
    21a6:	628b      	str	r3, [r1, #40]	; 0x28
    dfll_ctrl.bit.ONDEMAND = 0;                                 // Oscillator always on
    dfll_ctrl.bit.RUNSTDBY = 0;                                 // Do not run in standby
    dfll_ctrl.bit.USBCRM = 0;                                   // No USB recovery mode
    dfll_ctrl.bit.STABLE = 0;                                   // FINE calibration tracks changes
    dfll_ctrl.bit.MODE = 0;                                     // Open loop operation
    while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY));    // Wait for sync
    21a8:	2210      	movs	r2, #16
    21aa:	68cb      	ldr	r3, [r1, #12]
    21ac:	421a      	tst	r2, r3
    21ae:	d0fc      	beq.n	21aa <clocks_start_48MDFLL+0x6e>
    SYSCTRL->DFLLCTRL = dfll_ctrl;                              // Write register
    21b0:	4b0a      	ldr	r3, [pc, #40]	; (21dc <clocks_start_48MDFLL+0xa0>)
    21b2:	2202      	movs	r2, #2
    21b4:	849a      	strh	r2, [r3, #36]	; 0x24
    /* Wait for lock */
    while (SYSCTRL->PCLKSR.reg & (SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC));
    21b6:	0019      	movs	r1, r3
    21b8:	32ce      	adds	r2, #206	; 0xce
    21ba:	68cb      	ldr	r3, [r1, #12]
    21bc:	421a      	tst	r2, r3
    21be:	d1fc      	bne.n	21ba <clocks_start_48MDFLL+0x7e>
    genctrl.bit.ID = GCLK_CLKCTRL_GEN_GCLK0_Val;                // Select gclk0
    genctrl.bit.SRC = GCLK_GENCTRL_SRC_DFLL48M_Val;             // Assign 48M oscillator
    genctrl.bit.GENEN = 1;                                      // Enable generator
    genctrl.bit.DIVSEL = 0;                                     // Divide clock by gendiv.div
    genctrl.bit.OE = 1;                                         // Output clock
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);     // Wait for sync
    21c0:	4a05      	ldr	r2, [pc, #20]	; (21d8 <clocks_start_48MDFLL+0x9c>)
    21c2:	7853      	ldrb	r3, [r2, #1]
    21c4:	b25b      	sxtb	r3, r3
    21c6:	2b00      	cmp	r3, #0
    21c8:	dbfb      	blt.n	21c2 <clocks_start_48MDFLL+0x86>
    GCLK->GENCTRL = genctrl;                                    // Write register
    21ca:	4b03      	ldr	r3, [pc, #12]	; (21d8 <clocks_start_48MDFLL+0x9c>)
    21cc:	4a07      	ldr	r2, [pc, #28]	; (21ec <clocks_start_48MDFLL+0xb0>)
    21ce:	605a      	str	r2, [r3, #4]
    21d0:	4770      	bx	lr
    21d2:	46c0      	nop			; (mov r8, r8)
    21d4:	41004000 	.word	0x41004000
    21d8:	40000c00 	.word	0x40000c00
    21dc:	40000800 	.word	0x40000800
    21e0:	fffffcff 	.word	0xfffffcff
    21e4:	00806024 	.word	0x00806024
    21e8:	00806028 	.word	0x00806028
    21ec:	00090700 	.word	0x00090700

000021f0 <comms_main_init_rx>:

/*! \fn     comms_main_init_rx(void)
*   \brief  Init communications with aux MCU
*/
void comms_main_init_rx(void)
{
    21f0:	b510      	push	{r4, lr}
    dma_main_mcu_init_rx_transfer();
    21f2:	4b01      	ldr	r3, [pc, #4]	; (21f8 <comms_main_init_rx+0x8>)
    21f4:	4798      	blx	r3
}
    21f6:	bd10      	pop	{r4, pc}
    21f8:	000027fd 	.word	0x000027fd

000021fc <comms_main_mcu_send_message>:
*   \param  message         Pointer to the message to send
*   \param  message_length  Message length
*   \note   Transfer is done through DMA so data will be accessed after this function returns
*/
void comms_main_mcu_send_message(aux_mcu_message_t* message, uint16_t message_length)
{
    21fc:	b510      	push	{r4, lr}
    21fe:	0001      	movs	r1, r0
    /* To implement here in the future: no comms check */
    
    /* The function below does wait for a previous transfer to finish */
    dma_main_mcu_init_tx_transfer((void*)&AUXMCU_SERCOM->USART.DATA.reg, (void*)message, sizeof(aux_mcu_message_t));    
    2200:	2288      	movs	r2, #136	; 0x88
    2202:	0092      	lsls	r2, r2, #2
    2204:	4801      	ldr	r0, [pc, #4]	; (220c <comms_main_mcu_send_message+0x10>)
    2206:	4b02      	ldr	r3, [pc, #8]	; (2210 <comms_main_mcu_send_message+0x14>)
    2208:	4798      	blx	r3
}
    220a:	bd10      	pop	{r4, pc}
    220c:	42001428 	.word	0x42001428
    2210:	000027b1 	.word	0x000027b1

00002214 <comms_main_mcu_deal_with_non_usb_non_ble_message>:
/*! \fn     comms_main_mcu_deal_with_non_usb_non_ble_message(void)
*   \brief  Routine dealing with non USB & non BLE messages
*   \param  message Message to deal with
*/
void comms_main_mcu_deal_with_non_usb_non_ble_message(aux_mcu_message_t* message)
{
    2214:	b510      	push	{r4, lr}
    if (message->message_type == AUX_MCU_MSG_TYPE_PLAT_DETAILS)
    2216:	8803      	ldrh	r3, [r0, #0]
    2218:	2b03      	cmp	r3, #3
    221a:	d002      	beq.n	2222 <comms_main_mcu_deal_with_non_usb_non_ble_message+0xe>
        main_mcu_send_message.aux_details_message.aux_uid_registers[3] = *(uint32_t*)0x0080A048;
        
        /* Send message */
        comms_main_mcu_send_message((void*)&main_mcu_send_message, (uint16_t)sizeof(main_mcu_send_message));
    }
    else if (message->message_type == AUX_MCU_MSG_TYPE_MAIN_MCU_CMD)
    221c:	2b04      	cmp	r3, #4
    221e:	d01c      	beq.n	225a <comms_main_mcu_deal_with_non_usb_non_ble_message+0x46>
                udc_attach();
                break;
            }
        }
    }
}
    2220:	bd10      	pop	{r4, pc}
        main_mcu_send_message.message_type = message->message_type;
    2222:	4817      	ldr	r0, [pc, #92]	; (2280 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x6c>)
    2224:	8003      	strh	r3, [r0, #0]
        main_mcu_send_message.payload_length1 = sizeof(aux_plat_details_message_t);
    2226:	3321      	adds	r3, #33	; 0x21
    2228:	8043      	strh	r3, [r0, #2]
        main_mcu_send_message.aux_details_message.aux_fw_ver_major = FW_MAJOR;
    222a:	2300      	movs	r3, #0
    222c:	8083      	strh	r3, [r0, #4]
        main_mcu_send_message.aux_details_message.aux_fw_ver_minor = FW_MINOR;
    222e:	3301      	adds	r3, #1
    2230:	80c3      	strh	r3, [r0, #6]
        main_mcu_send_message.aux_details_message.aux_did_register = DSU->DID.reg;
    2232:	4b14      	ldr	r3, [pc, #80]	; (2284 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x70>)
    2234:	699b      	ldr	r3, [r3, #24]
    2236:	6083      	str	r3, [r0, #8]
        main_mcu_send_message.aux_details_message.aux_uid_registers[0] = *(uint32_t*)0x0080A00C;
    2238:	4b13      	ldr	r3, [pc, #76]	; (2288 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x74>)
    223a:	681b      	ldr	r3, [r3, #0]
    223c:	60c3      	str	r3, [r0, #12]
        main_mcu_send_message.aux_details_message.aux_uid_registers[1] = *(uint32_t*)0x0080A040;
    223e:	4b13      	ldr	r3, [pc, #76]	; (228c <comms_main_mcu_deal_with_non_usb_non_ble_message+0x78>)
    2240:	681b      	ldr	r3, [r3, #0]
    2242:	6103      	str	r3, [r0, #16]
        main_mcu_send_message.aux_details_message.aux_uid_registers[2] = *(uint32_t*)0x0080A044;
    2244:	4b12      	ldr	r3, [pc, #72]	; (2290 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x7c>)
    2246:	681b      	ldr	r3, [r3, #0]
    2248:	6143      	str	r3, [r0, #20]
        main_mcu_send_message.aux_details_message.aux_uid_registers[3] = *(uint32_t*)0x0080A048;
    224a:	4b12      	ldr	r3, [pc, #72]	; (2294 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x80>)
    224c:	681b      	ldr	r3, [r3, #0]
    224e:	6183      	str	r3, [r0, #24]
        comms_main_mcu_send_message((void*)&main_mcu_send_message, (uint16_t)sizeof(main_mcu_send_message));
    2250:	2188      	movs	r1, #136	; 0x88
    2252:	0089      	lsls	r1, r1, #2
    2254:	4b10      	ldr	r3, [pc, #64]	; (2298 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x84>)
    2256:	4798      	blx	r3
    2258:	e7e2      	b.n	2220 <comms_main_mcu_deal_with_non_usb_non_ble_message+0xc>
        switch(message->main_mcu_command_message.command)
    225a:	8883      	ldrh	r3, [r0, #4]
    225c:	2b02      	cmp	r3, #2
    225e:	d00b      	beq.n	2278 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x64>
    2260:	2b03      	cmp	r3, #3
    2262:	d004      	beq.n	226e <comms_main_mcu_deal_with_non_usb_non_ble_message+0x5a>
    2264:	2b01      	cmp	r3, #1
    2266:	d1db      	bne.n	2220 <comms_main_mcu_deal_with_non_usb_non_ble_message+0xc>
                main_standby_sleep();
    2268:	4b0c      	ldr	r3, [pc, #48]	; (229c <comms_main_mcu_deal_with_non_usb_non_ble_message+0x88>)
    226a:	4798      	blx	r3
                break;
    226c:	e7d8      	b.n	2220 <comms_main_mcu_deal_with_non_usb_non_ble_message+0xc>
                comms_main_mcu_send_message((void*)message, (uint16_t)sizeof(aux_mcu_message_t));
    226e:	2188      	movs	r1, #136	; 0x88
    2270:	0089      	lsls	r1, r1, #2
    2272:	4b09      	ldr	r3, [pc, #36]	; (2298 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x84>)
    2274:	4798      	blx	r3
                break;
    2276:	e7d3      	b.n	2220 <comms_main_mcu_deal_with_non_usb_non_ble_message+0xc>
                udc_attach();
    2278:	4b09      	ldr	r3, [pc, #36]	; (22a0 <comms_main_mcu_deal_with_non_usb_non_ble_message+0x8c>)
    227a:	4798      	blx	r3
}
    227c:	e7d0      	b.n	2220 <comms_main_mcu_deal_with_non_usb_non_ble_message+0xc>
    227e:	46c0      	nop			; (mov r8, r8)
    2280:	20000340 	.word	0x20000340
    2284:	41002000 	.word	0x41002000
    2288:	0080a00c 	.word	0x0080a00c
    228c:	0080a040 	.word	0x0080a040
    2290:	0080a044 	.word	0x0080a044
    2294:	0080a048 	.word	0x0080a048
    2298:	000021fd 	.word	0x000021fd
    229c:	0000383d 	.word	0x0000383d
    22a0:	00002d95 	.word	0x00002d95

000022a4 <comms_main_mcu_routine>:

/*! \fn     comms_main_mcu_routine(void)
*   \brief  Routine dealing with main mcu comms
*/
void comms_main_mcu_routine(void)
{	
    22a4:	b510      	push	{r4, lr}
    /* First: deal with fully received messages */
    if (dma_main_mcu_usb_msg_received != FALSE)
    22a6:	4b2e      	ldr	r3, [pc, #184]	; (2360 <comms_main_mcu_routine+0xbc>)
    22a8:	681b      	ldr	r3, [r3, #0]
    22aa:	2b00      	cmp	r3, #0
    22ac:	d008      	beq.n	22c0 <comms_main_mcu_routine+0x1c>
    {
        if (comms_main_mcu_usb_msg_answered_using_first_bytes == FALSE)
    22ae:	4b2d      	ldr	r3, [pc, #180]	; (2364 <comms_main_mcu_routine+0xc0>)
    22b0:	681b      	ldr	r3, [r3, #0]
    22b2:	2b00      	cmp	r3, #0
    22b4:	d02c      	beq.n	2310 <comms_main_mcu_routine+0x6c>
        {
            comms_usb_send_hid_message((aux_mcu_message_t*)&dma_main_mcu_usb_rcv_message);
        }
        comms_main_mcu_usb_msg_answered_using_first_bytes = FALSE;
    22b6:	2300      	movs	r3, #0
    22b8:	4a2a      	ldr	r2, [pc, #168]	; (2364 <comms_main_mcu_routine+0xc0>)
    22ba:	6013      	str	r3, [r2, #0]
        dma_main_mcu_usb_msg_received = FALSE;
    22bc:	4a28      	ldr	r2, [pc, #160]	; (2360 <comms_main_mcu_routine+0xbc>)
    22be:	6013      	str	r3, [r2, #0]
    }
    if (dma_main_mcu_ble_msg_received != FALSE)
    22c0:	4b29      	ldr	r3, [pc, #164]	; (2368 <comms_main_mcu_routine+0xc4>)
    22c2:	681b      	ldr	r3, [r3, #0]
    22c4:	2b00      	cmp	r3, #0
    22c6:	d004      	beq.n	22d2 <comms_main_mcu_routine+0x2e>
    {
        if (comms_main_mcu_ble_msg_answered_using_first_bytes == FALSE)
        {
            // TBD
        }
        comms_main_mcu_ble_msg_answered_using_first_bytes = FALSE;
    22c8:	2300      	movs	r3, #0
    22ca:	4a28      	ldr	r2, [pc, #160]	; (236c <comms_main_mcu_routine+0xc8>)
    22cc:	6013      	str	r3, [r2, #0]
        dma_main_mcu_ble_msg_received = FALSE;
    22ce:	4a26      	ldr	r2, [pc, #152]	; (2368 <comms_main_mcu_routine+0xc4>)
    22d0:	6013      	str	r3, [r2, #0]
    }
    if (dma_main_mcu_other_msg_received != FALSE)
    22d2:	4b27      	ldr	r3, [pc, #156]	; (2370 <comms_main_mcu_routine+0xcc>)
    22d4:	681b      	ldr	r3, [r3, #0]
    22d6:	2b00      	cmp	r3, #0
    22d8:	d008      	beq.n	22ec <comms_main_mcu_routine+0x48>
    {
        if (comms_main_mcu_other_msg_answered_using_first_bytes == FALSE)
    22da:	4b26      	ldr	r3, [pc, #152]	; (2374 <comms_main_mcu_routine+0xd0>)
    22dc:	681b      	ldr	r3, [r3, #0]
    22de:	2b00      	cmp	r3, #0
    22e0:	d01a      	beq.n	2318 <comms_main_mcu_routine+0x74>
        {
            comms_main_mcu_deal_with_non_usb_non_ble_message((aux_mcu_message_t*)&dma_main_mcu_other_message);
        }
        comms_main_mcu_other_msg_answered_using_first_bytes = FALSE;
    22e2:	2300      	movs	r3, #0
    22e4:	4a23      	ldr	r2, [pc, #140]	; (2374 <comms_main_mcu_routine+0xd0>)
    22e6:	6013      	str	r3, [r2, #0]
        dma_main_mcu_other_msg_received = FALSE;
    22e8:	4a21      	ldr	r2, [pc, #132]	; (2370 <comms_main_mcu_routine+0xcc>)
    22ea:	6013      	str	r3, [r2, #0]
    }
    
    /* Second: see if we could deal with a packet in advance */
    /* Ongoing RX transfer received bytes */
    uint16_t nb_received_bytes_for_ongoing_transfer = sizeof(dma_main_mcu_temp_rcv_message) - dma_main_mcu_get_remaining_bytes_for_rx_transfer();
    22ec:	4b22      	ldr	r3, [pc, #136]	; (2378 <comms_main_mcu_routine+0xd4>)
    22ee:	4798      	blx	r3
    22f0:	2388      	movs	r3, #136	; 0x88
    22f2:	009b      	lsls	r3, r3, #2
    22f4:	1a18      	subs	r0, r3, r0
    22f6:	b280      	uxth	r0, r0
    
    /* Depending on the message type, set the correct bool pointer */
    BOOL* answered_with_the_first_bytes_pointer = &comms_main_mcu_other_msg_answered_using_first_bytes;
    if (dma_main_mcu_temp_rcv_message.message_type == AUX_MCU_MSG_TYPE_USB)
    22f8:	4b20      	ldr	r3, [pc, #128]	; (237c <comms_main_mcu_routine+0xd8>)
    22fa:	881b      	ldrh	r3, [r3, #0]
    22fc:	b29b      	uxth	r3, r3
    22fe:	2b00      	cmp	r3, #0
    2300:	d010      	beq.n	2324 <comms_main_mcu_routine+0x80>
    {
        answered_with_the_first_bytes_pointer = &comms_main_mcu_usb_msg_answered_using_first_bytes;
    } 
    else if (dma_main_mcu_temp_rcv_message.message_type == AUX_MCU_MSG_TYPE_BLE)
    2302:	4b1e      	ldr	r3, [pc, #120]	; (237c <comms_main_mcu_routine+0xd8>)
    2304:	881b      	ldrh	r3, [r3, #0]
    2306:	b29b      	uxth	r3, r3
    2308:	2b01      	cmp	r3, #1
    230a:	d009      	beq.n	2320 <comms_main_mcu_routine+0x7c>
    BOOL* answered_with_the_first_bytes_pointer = &comms_main_mcu_other_msg_answered_using_first_bytes;
    230c:	4a19      	ldr	r2, [pc, #100]	; (2374 <comms_main_mcu_routine+0xd0>)
    230e:	e00a      	b.n	2326 <comms_main_mcu_routine+0x82>
            comms_usb_send_hid_message((aux_mcu_message_t*)&dma_main_mcu_usb_rcv_message);
    2310:	481b      	ldr	r0, [pc, #108]	; (2380 <comms_main_mcu_routine+0xdc>)
    2312:	4b1c      	ldr	r3, [pc, #112]	; (2384 <comms_main_mcu_routine+0xe0>)
    2314:	4798      	blx	r3
    2316:	e7ce      	b.n	22b6 <comms_main_mcu_routine+0x12>
            comms_main_mcu_deal_with_non_usb_non_ble_message((aux_mcu_message_t*)&dma_main_mcu_other_message);
    2318:	481b      	ldr	r0, [pc, #108]	; (2388 <comms_main_mcu_routine+0xe4>)
    231a:	4b1c      	ldr	r3, [pc, #112]	; (238c <comms_main_mcu_routine+0xe8>)
    231c:	4798      	blx	r3
    231e:	e7e0      	b.n	22e2 <comms_main_mcu_routine+0x3e>
    {
        answered_with_the_first_bytes_pointer = &comms_main_mcu_ble_msg_answered_using_first_bytes;
    2320:	4a12      	ldr	r2, [pc, #72]	; (236c <comms_main_mcu_routine+0xc8>)
    2322:	e000      	b.n	2326 <comms_main_mcu_routine+0x82>
        answered_with_the_first_bytes_pointer = &comms_main_mcu_usb_msg_answered_using_first_bytes;
    2324:	4a0f      	ldr	r2, [pc, #60]	; (2364 <comms_main_mcu_routine+0xc0>)
    }
    
    /* First part of message */
    if ((nb_received_bytes_for_ongoing_transfer >= sizeof(dma_main_mcu_temp_rcv_message.message_type) + sizeof(dma_main_mcu_temp_rcv_message.payload_length1) + dma_main_mcu_temp_rcv_message.payload_length1) && (*answered_with_the_first_bytes_pointer == FALSE))
    2326:	4b15      	ldr	r3, [pc, #84]	; (237c <comms_main_mcu_routine+0xd8>)
    2328:	885b      	ldrh	r3, [r3, #2]
    232a:	3304      	adds	r3, #4
    232c:	4298      	cmp	r0, r3
    232e:	d311      	bcc.n	2354 <comms_main_mcu_routine+0xb0>
    2330:	6813      	ldr	r3, [r2, #0]
    2332:	2b00      	cmp	r3, #0
    2334:	d10e      	bne.n	2354 <comms_main_mcu_routine+0xb0>
    {
        /* Set bool and do necessary action */
        *answered_with_the_first_bytes_pointer = TRUE;
    2336:	3301      	adds	r3, #1
    2338:	6013      	str	r3, [r2, #0]
        if (dma_main_mcu_temp_rcv_message.message_type == AUX_MCU_MSG_TYPE_USB)
    233a:	4b10      	ldr	r3, [pc, #64]	; (237c <comms_main_mcu_routine+0xd8>)
    233c:	881b      	ldrh	r3, [r3, #0]
    233e:	b29b      	uxth	r3, r3
    2340:	2b00      	cmp	r3, #0
    2342:	d008      	beq.n	2356 <comms_main_mcu_routine+0xb2>
        {
            comms_usb_send_hid_message((aux_mcu_message_t*)&dma_main_mcu_temp_rcv_message);
        }
        else if (dma_main_mcu_temp_rcv_message.message_type == AUX_MCU_MSG_TYPE_BLE)
    2344:	4b0d      	ldr	r3, [pc, #52]	; (237c <comms_main_mcu_routine+0xd8>)
    2346:	881b      	ldrh	r3, [r3, #0]
    2348:	b29b      	uxth	r3, r3
    234a:	2b01      	cmp	r3, #1
    234c:	d002      	beq.n	2354 <comms_main_mcu_routine+0xb0>
        {
            // TBD
        }
        else
        {
            comms_main_mcu_deal_with_non_usb_non_ble_message((aux_mcu_message_t*)&dma_main_mcu_temp_rcv_message);            
    234e:	480b      	ldr	r0, [pc, #44]	; (237c <comms_main_mcu_routine+0xd8>)
    2350:	4b0e      	ldr	r3, [pc, #56]	; (238c <comms_main_mcu_routine+0xe8>)
    2352:	4798      	blx	r3
        }
    }
    2354:	bd10      	pop	{r4, pc}
            comms_usb_send_hid_message((aux_mcu_message_t*)&dma_main_mcu_temp_rcv_message);
    2356:	4809      	ldr	r0, [pc, #36]	; (237c <comms_main_mcu_routine+0xd8>)
    2358:	4b0a      	ldr	r3, [pc, #40]	; (2384 <comms_main_mcu_routine+0xe0>)
    235a:	4798      	blx	r3
    235c:	e7fa      	b.n	2354 <comms_main_mcu_routine+0xb0>
    235e:	46c0      	nop			; (mov r8, r8)
    2360:	200001b0 	.word	0x200001b0
    2364:	20000104 	.word	0x20000104
    2368:	200001a8 	.word	0x200001a8
    236c:	200000fc 	.word	0x200000fc
    2370:	200001ac 	.word	0x200001ac
    2374:	20000100 	.word	0x20000100
    2378:	0000278d 	.word	0x0000278d
    237c:	20000790 	.word	0x20000790
    2380:	200009b0 	.word	0x200009b0
    2384:	00002405 	.word	0x00002405
    2388:	20000e60 	.word	0x20000e60
    238c:	00002215 	.word	0x00002215

00002390 <comms_usb_raw_hid_recv_callback>:
*   \brief  Function called when a HID packet is received
*/
void comms_usb_raw_hid_recv_callback(uint16_t recv_bytes)
{
    /* Set number of received bytes */
    comms_usb_raw_hid_packet_receive_length = recv_bytes;
    2390:	4b02      	ldr	r3, [pc, #8]	; (239c <comms_usb_raw_hid_recv_callback+0xc>)
    2392:	6018      	str	r0, [r3, #0]
    
    /* Set flag */
    comms_usb_raw_hid_packet_received = TRUE;
    2394:	2201      	movs	r2, #1
    2396:	4b02      	ldr	r3, [pc, #8]	; (23a0 <comms_usb_raw_hid_recv_callback+0x10>)
    2398:	601a      	str	r2, [r3, #0]
}
    239a:	4770      	bx	lr
    239c:	20000114 	.word	0x20000114
    23a0:	20000118 	.word	0x20000118

000023a4 <comms_usb_raw_hid_send_callback>:
*   \brief  Function called when a HID packet is sent
*/
void comms_usb_raw_hid_send_callback(void)
{
    /* Set flag */
    comms_usb_raw_hid_packet_being_sent = FALSE;
    23a4:	2200      	movs	r2, #0
    23a6:	4b01      	ldr	r3, [pc, #4]	; (23ac <comms_usb_raw_hid_send_callback+0x8>)
    23a8:	601a      	str	r2, [r3, #0]
}
    23aa:	4770      	bx	lr
    23ac:	20000110 	.word	0x20000110

000023b0 <comms_usb_arm_packet_receive>:

/*! \fn     comms_usb_arm_packet_receive(void)
*   \brief  Arm packet receive
*/
void comms_usb_arm_packet_receive(void)
{
    23b0:	b510      	push	{r4, lr}
    usb_recv(USB_RAWHID_TX_ENDPOINT, (uint8_t*)&raw_hid_recv_buffer, sizeof(raw_hid_recv_buffer));
    23b2:	2240      	movs	r2, #64	; 0x40
    23b4:	4902      	ldr	r1, [pc, #8]	; (23c0 <comms_usb_arm_packet_receive+0x10>)
    23b6:	2002      	movs	r0, #2
    23b8:	4b02      	ldr	r3, [pc, #8]	; (23c4 <comms_usb_arm_packet_receive+0x14>)
    23ba:	4798      	blx	r3
}
    23bc:	bd10      	pop	{r4, pc}
    23be:	46c0      	nop			; (mov r8, r8)
    23c0:	20000124 	.word	0x20000124
    23c4:	00003309 	.word	0x00003309

000023c8 <comms_usb_send_raw_hid_packet>:
*   \param  packet          Packet to send (must be 4 bytes aligned!)
*   \param  wait_send       Set to wait for end of packet transmission
*   \param  payload_size    Payload size
*/
void comms_usb_send_raw_hid_packet(hid_packet_t* packet, BOOL wait_send, uint16_t payload_size)
{
    23c8:	b510      	push	{r4, lr}
    23ca:	000c      	movs	r4, r1
    /* Wait for possible previous packet to be sent */
    while(comms_usb_raw_hid_packet_being_sent == TRUE);
    23cc:	490b      	ldr	r1, [pc, #44]	; (23fc <comms_usb_send_raw_hid_packet+0x34>)
    23ce:	680b      	ldr	r3, [r1, #0]
    23d0:	2b01      	cmp	r3, #1
    23d2:	d0fc      	beq.n	23ce <comms_usb_send_raw_hid_packet+0x6>
    
    /* Reset flag */
    comms_usb_raw_hid_packet_being_sent = TRUE;
    23d4:	2101      	movs	r1, #1
    23d6:	4b09      	ldr	r3, [pc, #36]	; (23fc <comms_usb_send_raw_hid_packet+0x34>)
    23d8:	6019      	str	r1, [r3, #0]
    {
        payload_size = sizeof(hid_packet_t);
    }
    
    /* Send packet */
    usb_send(USB_RAWHID_RX_ENDPOINT, (uint8_t*)packet, payload_size);
    23da:	1c13      	adds	r3, r2, #0
    23dc:	2a40      	cmp	r2, #64	; 0x40
    23de:	d900      	bls.n	23e2 <comms_usb_send_raw_hid_packet+0x1a>
    23e0:	2340      	movs	r3, #64	; 0x40
    23e2:	b29a      	uxth	r2, r3
    23e4:	0001      	movs	r1, r0
    23e6:	2001      	movs	r0, #1
    23e8:	4b05      	ldr	r3, [pc, #20]	; (2400 <comms_usb_send_raw_hid_packet+0x38>)
    23ea:	4798      	blx	r3
    
    /* If asked, wait */
    if (wait_send != FALSE)
    23ec:	2c00      	cmp	r4, #0
    23ee:	d003      	beq.n	23f8 <comms_usb_send_raw_hid_packet+0x30>
    {
        while(comms_usb_raw_hid_packet_being_sent == TRUE);
    23f0:	4a02      	ldr	r2, [pc, #8]	; (23fc <comms_usb_send_raw_hid_packet+0x34>)
    23f2:	6813      	ldr	r3, [r2, #0]
    23f4:	2b01      	cmp	r3, #1
    23f6:	d0fc      	beq.n	23f2 <comms_usb_send_raw_hid_packet+0x2a>
    }    
}
    23f8:	bd10      	pop	{r4, pc}
    23fa:	46c0      	nop			; (mov r8, r8)
    23fc:	20000110 	.word	0x20000110
    2400:	000032fd 	.word	0x000032fd

00002404 <comms_usb_send_hid_message>:
/*! \fn     comms_usb_send_hid_message(aux_mcu_message_t* message)
*   \brief  send HID message to PC
*   \param  message     Message to send
*/
void comms_usb_send_hid_message(aux_mcu_message_t* message)
{
    2404:	b5f0      	push	{r4, r5, r6, r7, lr}
    2406:	46de      	mov	lr, fp
    2408:	4657      	mov	r7, sl
    240a:	464e      	mov	r6, r9
    240c:	4645      	mov	r5, r8
    240e:	b5e0      	push	{r5, r6, r7, lr}
    2410:	b083      	sub	sp, #12
    2412:	9001      	str	r0, [sp, #4]
    dbg_mcu_hid_msg_recv++;
    2414:	4a31      	ldr	r2, [pc, #196]	; (24dc <comms_usb_send_hid_message+0xd8>)
    2416:	8813      	ldrh	r3, [r2, #0]
    2418:	3301      	adds	r3, #1
    241a:	8013      	strh	r3, [r2, #0]
    uint8_t total_number_of_packets = ((message->payload_length1 + sizeof(raw_hid_send_buffer.payload) - 1)/sizeof(raw_hid_send_buffer.payload))-1;
    241c:	8846      	ldrh	r6, [r0, #2]
    241e:	0030      	movs	r0, r6
    2420:	303d      	adds	r0, #61	; 0x3d
    2422:	213e      	movs	r1, #62	; 0x3e
    2424:	4b2e      	ldr	r3, [pc, #184]	; (24e0 <comms_usb_send_hid_message+0xdc>)
    2426:	4798      	blx	r3
    2428:	3801      	subs	r0, #1
    242a:	b2c0      	uxtb	r0, r0
    uint16_t remaining_payload_to_send = message->payload_length1;
    uint16_t payload_offset = 0;
    uint8_t packet_id = 0;
    
    /* Generate and send packets */
    while(remaining_payload_to_send > 0)
    242c:	2e00      	cmp	r6, #0
    242e:	d04e      	beq.n	24ce <comms_usb_send_hid_message+0xca>
    2430:	2300      	movs	r3, #0
    2432:	4698      	mov	r8, r3
    2434:	2700      	movs	r7, #0
    {
        /* Wait for a possible previous packet to be sent as we do buffer re-use */
        while(comms_usb_raw_hid_packet_being_sent == TRUE);
    2436:	4d2b      	ldr	r5, [pc, #172]	; (24e4 <comms_usb_send_hid_message+0xe0>)
        
        /* Generate packet */
        memset((void*)&raw_hid_send_buffer, 0, sizeof(raw_hid_send_buffer));
    2438:	4b2b      	ldr	r3, [pc, #172]	; (24e8 <comms_usb_send_hid_message+0xe4>)
    243a:	469a      	mov	sl, r3
        raw_hid_send_buffer.byte1.total_packets = total_number_of_packets;
    243c:	230f      	movs	r3, #15
    243e:	4699      	mov	r9, r3
    2440:	4003      	ands	r3, r0
    2442:	469b      	mov	fp, r3
    2444:	e024      	b.n	2490 <comms_usb_send_hid_message+0x8c>
        {
            raw_hid_send_buffer.byte0.payload_len = sizeof(raw_hid_send_buffer.payload);
        }
        else
        {
            raw_hid_send_buffer.byte0.payload_len = remaining_payload_to_send;            
    2446:	4928      	ldr	r1, [pc, #160]	; (24e8 <comms_usb_send_hid_message+0xe4>)
    2448:	223f      	movs	r2, #63	; 0x3f
    244a:	4032      	ands	r2, r6
    244c:	780b      	ldrb	r3, [r1, #0]
    244e:	203f      	movs	r0, #63	; 0x3f
    2450:	4383      	bics	r3, r0
    2452:	4313      	orrs	r3, r2
    2454:	700b      	strb	r3, [r1, #0]
        }
        
        /* Copy payload */
        memcpy(raw_hid_send_buffer.payload, &(message->payload[payload_offset]), raw_hid_send_buffer.byte0.payload_len);
    2456:	4b24      	ldr	r3, [pc, #144]	; (24e8 <comms_usb_send_hid_message+0xe4>)
    2458:	781c      	ldrb	r4, [r3, #0]
    245a:	06a4      	lsls	r4, r4, #26
    245c:	0ea4      	lsrs	r4, r4, #26
    245e:	1d39      	adds	r1, r7, #4
    2460:	9b01      	ldr	r3, [sp, #4]
    2462:	469c      	mov	ip, r3
    2464:	4461      	add	r1, ip
    2466:	0022      	movs	r2, r4
    2468:	4820      	ldr	r0, [pc, #128]	; (24ec <comms_usb_send_hid_message+0xe8>)
    246a:	4b21      	ldr	r3, [pc, #132]	; (24f0 <comms_usb_send_hid_message+0xec>)
    246c:	4798      	blx	r3
        
        /* update local vars */
        remaining_payload_to_send -= raw_hid_send_buffer.byte0.payload_len;
    246e:	b2a2      	uxth	r2, r4
    2470:	1ab6      	subs	r6, r6, r2
    2472:	b2b6      	uxth	r6, r6
        payload_offset += raw_hid_send_buffer.byte0.payload_len;
    2474:	19d7      	adds	r7, r2, r7
    2476:	b2bf      	uxth	r7, r7
        packet_id += 1;
        
        /* Send packet */
        comms_usb_send_raw_hid_packet(&raw_hid_send_buffer, TRUE, sizeof(raw_hid_send_buffer.byte0) + sizeof(raw_hid_send_buffer.byte1) + raw_hid_send_buffer.byte0.payload_len);
    2478:	3202      	adds	r2, #2
    247a:	2101      	movs	r1, #1
    247c:	481a      	ldr	r0, [pc, #104]	; (24e8 <comms_usb_send_hid_message+0xe4>)
    247e:	4b1d      	ldr	r3, [pc, #116]	; (24f4 <comms_usb_send_hid_message+0xf0>)
    2480:	4798      	blx	r3
    2482:	4643      	mov	r3, r8
    2484:	3301      	adds	r3, #1
    2486:	464a      	mov	r2, r9
    2488:	401a      	ands	r2, r3
    248a:	4690      	mov	r8, r2
    while(remaining_payload_to_send > 0)
    248c:	2e00      	cmp	r6, #0
    248e:	d01e      	beq.n	24ce <comms_usb_send_hid_message+0xca>
        while(comms_usb_raw_hid_packet_being_sent == TRUE);
    2490:	682b      	ldr	r3, [r5, #0]
    2492:	2b01      	cmp	r3, #1
    2494:	d0fc      	beq.n	2490 <comms_usb_send_hid_message+0x8c>
        memset((void*)&raw_hid_send_buffer, 0, sizeof(raw_hid_send_buffer));
    2496:	2240      	movs	r2, #64	; 0x40
    2498:	2100      	movs	r1, #0
    249a:	4650      	mov	r0, sl
    249c:	4b16      	ldr	r3, [pc, #88]	; (24f8 <comms_usb_send_hid_message+0xf4>)
    249e:	4798      	blx	r3
        raw_hid_send_buffer.byte1.total_packets = total_number_of_packets;
    24a0:	4653      	mov	r3, sl
    24a2:	785b      	ldrb	r3, [r3, #1]
    24a4:	464a      	mov	r2, r9
    24a6:	4393      	bics	r3, r2
        raw_hid_send_buffer.byte1.packet_id = packet_id;
    24a8:	4642      	mov	r2, r8
    24aa:	0112      	lsls	r2, r2, #4
    24ac:	4659      	mov	r1, fp
    24ae:	430b      	orrs	r3, r1
    24b0:	4649      	mov	r1, r9
    24b2:	400b      	ands	r3, r1
    24b4:	4313      	orrs	r3, r2
    24b6:	4652      	mov	r2, sl
    24b8:	7053      	strb	r3, [r2, #1]
        if (remaining_payload_to_send > sizeof(raw_hid_send_buffer.payload))
    24ba:	2e3e      	cmp	r6, #62	; 0x3e
    24bc:	d9c3      	bls.n	2446 <comms_usb_send_hid_message+0x42>
            raw_hid_send_buffer.byte0.payload_len = sizeof(raw_hid_send_buffer.payload);
    24be:	4a0a      	ldr	r2, [pc, #40]	; (24e8 <comms_usb_send_hid_message+0xe4>)
    24c0:	7813      	ldrb	r3, [r2, #0]
    24c2:	213f      	movs	r1, #63	; 0x3f
    24c4:	438b      	bics	r3, r1
    24c6:	213e      	movs	r1, #62	; 0x3e
    24c8:	430b      	orrs	r3, r1
    24ca:	7013      	strb	r3, [r2, #0]
    24cc:	e7c3      	b.n	2456 <comms_usb_send_hid_message+0x52>
    }
}
    24ce:	b003      	add	sp, #12
    24d0:	bc3c      	pop	{r2, r3, r4, r5}
    24d2:	4690      	mov	r8, r2
    24d4:	4699      	mov	r9, r3
    24d6:	46a2      	mov	sl, r4
    24d8:	46ab      	mov	fp, r5
    24da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    24dc:	2000011e 	.word	0x2000011e
    24e0:	0000388d 	.word	0x0000388d
    24e4:	20000110 	.word	0x20000110
    24e8:	20000164 	.word	0x20000164
    24ec:	20000166 	.word	0x20000166
    24f0:	000039ed 	.word	0x000039ed
    24f4:	000023c9 	.word	0x000023c9
    24f8:	000039ff 	.word	0x000039ff

000024fc <comms_usb_configuration_callback>:

/*! \fn     comms_usb_configuration_callback(int config)
*   \brief  Called when device is configured, initialize USB comms
*/
void comms_usb_configuration_callback(int config)
{
    24fc:	b510      	push	{r4, lr}
    /* Unused */
    (void)config;
    
    /* Reset global vars */
    comms_usb_expect_flip_bit_state_set = FALSE;
    24fe:	2300      	movs	r3, #0
    2500:	4a04      	ldr	r2, [pc, #16]	; (2514 <comms_usb_configuration_callback+0x18>)
    2502:	6013      	str	r3, [r2, #0]
    comms_usb_temp_mcu_message_fill_index = 0;
    2504:	4a04      	ldr	r2, [pc, #16]	; (2518 <comms_usb_configuration_callback+0x1c>)
    2506:	8013      	strh	r3, [r2, #0]
    comms_usb_expected_packet_number = 0;
    2508:	4a04      	ldr	r2, [pc, #16]	; (251c <comms_usb_configuration_callback+0x20>)
    250a:	8013      	strh	r3, [r2, #0]
    
    /* Start receiving raw HID packets */
    comms_usb_arm_packet_receive();
    250c:	4b04      	ldr	r3, [pc, #16]	; (2520 <comms_usb_configuration_callback+0x24>)
    250e:	4798      	blx	r3
} 
    2510:	bd10      	pop	{r4, pc}
    2512:	46c0      	nop			; (mov r8, r8)
    2514:	20000108 	.word	0x20000108
    2518:	2000011c 	.word	0x2000011c
    251c:	2000010c 	.word	0x2000010c
    2520:	000023b1 	.word	0x000023b1

00002524 <comms_usb_communication_routine>:

/*! \fn     comms_usb_communication_routine(void)
*   \brief  Function called to deal with comms
*/
void comms_usb_communication_routine(void)
{
    2524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* Did we receive a packet? */
    if (comms_usb_raw_hid_packet_received != FALSE)
    2526:	4b50      	ldr	r3, [pc, #320]	; (2668 <comms_usb_communication_routine+0x144>)
    2528:	681b      	ldr	r3, [r3, #0]
    252a:	2b00      	cmp	r3, #0
    252c:	d066      	beq.n	25fc <comms_usb_communication_routine+0xd8>
    {
        /* Reset flag */
        comms_usb_raw_hid_packet_received = FALSE;
    252e:	2200      	movs	r2, #0
    2530:	4b4d      	ldr	r3, [pc, #308]	; (2668 <comms_usb_communication_routine+0x144>)
    2532:	601a      	str	r2, [r3, #0]
        
        /* Check for bit flip state: if it doesn't match, restart state machine */
        if (((comms_usb_expect_flip_bit_state_set != FALSE) && (raw_hid_recv_buffer.byte0.flip_bit == 0)) || ((comms_usb_expect_flip_bit_state_set == FALSE) && (raw_hid_recv_buffer.byte0.flip_bit != 0)))
    2534:	4b4d      	ldr	r3, [pc, #308]	; (266c <comms_usb_communication_routine+0x148>)
    2536:	681b      	ldr	r3, [r3, #0]
    2538:	2b00      	cmp	r3, #0
    253a:	d033      	beq.n	25a4 <comms_usb_communication_routine+0x80>
    253c:	4b4c      	ldr	r3, [pc, #304]	; (2670 <comms_usb_communication_routine+0x14c>)
    253e:	781b      	ldrb	r3, [r3, #0]
    2540:	2b7f      	cmp	r3, #127	; 0x7f
    2542:	d833      	bhi.n	25ac <comms_usb_communication_routine+0x88>
        {
            if (raw_hid_recv_buffer.byte0.flip_bit == 0)
            {
                comms_usb_expect_flip_bit_state_set = FALSE;
    2544:	2200      	movs	r2, #0
    2546:	4b49      	ldr	r3, [pc, #292]	; (266c <comms_usb_communication_routine+0x148>)
    2548:	601a      	str	r2, [r3, #0]
            } 
            else
            {
                comms_usb_expect_flip_bit_state_set = TRUE;
            }
            comms_usb_temp_mcu_message_fill_index = 0;
    254a:	2300      	movs	r3, #0
    254c:	4a49      	ldr	r2, [pc, #292]	; (2674 <comms_usb_communication_routine+0x150>)
    254e:	8013      	strh	r3, [r2, #0]
            comms_usb_expected_packet_number = 0;
    2550:	4a49      	ldr	r2, [pc, #292]	; (2678 <comms_usb_communication_routine+0x154>)
    2552:	8013      	strh	r3, [r2, #0]
        }
        
        /* Check for expected packet number */
        if ((comms_usb_expected_packet_number != 0) && (raw_hid_recv_buffer.byte1.packet_id != comms_usb_expected_packet_number))
    2554:	2600      	movs	r6, #0
            comms_usb_arm_packet_receive();
            return;            
        }
        
        /* If first packet, store total number of packets for this hid message */
        if (raw_hid_recv_buffer.byte1.packet_id == 0)
    2556:	4b46      	ldr	r3, [pc, #280]	; (2670 <comms_usb_communication_routine+0x14c>)
    2558:	785b      	ldrb	r3, [r3, #1]
    255a:	220f      	movs	r2, #15
    255c:	4393      	bics	r3, r2
    255e:	d036      	beq.n	25ce <comms_usb_communication_routine+0xaa>
            memset((void*)&comms_usb_temp_mcu_message_to_send, 0, sizeof(comms_usb_temp_mcu_message_to_send));
            comms_usb_temp_mcu_message_to_send.message_type = AUX_MCU_MSG_TYPE_USB;
        }
        
        /* Check for overflow tentative */
        if ((size_t)(comms_usb_temp_mcu_message_fill_index + raw_hid_recv_buffer.byte0.payload_len) > sizeof(comms_usb_temp_mcu_message_to_send.payload))
    2560:	4b44      	ldr	r3, [pc, #272]	; (2674 <comms_usb_communication_routine+0x150>)
    2562:	881d      	ldrh	r5, [r3, #0]
    2564:	4b42      	ldr	r3, [pc, #264]	; (2670 <comms_usb_communication_routine+0x14c>)
    2566:	781b      	ldrb	r3, [r3, #0]
    2568:	069b      	lsls	r3, r3, #26
    256a:	0e9c      	lsrs	r4, r3, #26
    256c:	192a      	adds	r2, r5, r4
    256e:	2386      	movs	r3, #134	; 0x86
    2570:	009b      	lsls	r3, r3, #2
    2572:	429a      	cmp	r2, r3
    2574:	d83b      	bhi.n	25ee <comms_usb_communication_routine+0xca>
            comms_usb_arm_packet_receive();
            return;
        }
        
        /* Fill temp mcu message payload */
        memcpy((void*)&comms_usb_temp_mcu_message_to_send.payload[comms_usb_temp_mcu_message_fill_index], (void*)raw_hid_recv_buffer.payload, raw_hid_recv_buffer.byte0.payload_len);
    2576:	1d28      	adds	r0, r5, #4
    2578:	4b40      	ldr	r3, [pc, #256]	; (267c <comms_usb_communication_routine+0x158>)
    257a:	18c0      	adds	r0, r0, r3
    257c:	4f3c      	ldr	r7, [pc, #240]	; (2670 <comms_usb_communication_routine+0x14c>)
    257e:	1cb9      	adds	r1, r7, #2
    2580:	0022      	movs	r2, r4
    2582:	4b3f      	ldr	r3, [pc, #252]	; (2680 <comms_usb_communication_routine+0x15c>)
    2584:	4798      	blx	r3
        comms_usb_temp_mcu_message_fill_index += raw_hid_recv_buffer.byte0.payload_len;
    2586:	192c      	adds	r4, r5, r4
    2588:	4b3a      	ldr	r3, [pc, #232]	; (2674 <comms_usb_communication_routine+0x150>)
    258a:	801c      	strh	r4, [r3, #0]
        comms_usb_expected_packet_number++;
    258c:	3601      	adds	r6, #1
    258e:	4a3a      	ldr	r2, [pc, #232]	; (2678 <comms_usb_communication_routine+0x154>)
    2590:	8016      	strh	r6, [r2, #0]
        
        /* Check for last message */
        if (raw_hid_recv_buffer.byte1.packet_id == comms_usb_total_expected_packets)
    2592:	787b      	ldrb	r3, [r7, #1]
    2594:	091b      	lsrs	r3, r3, #4
    2596:	4a3b      	ldr	r2, [pc, #236]	; (2684 <comms_usb_communication_routine+0x160>)
    2598:	8812      	ldrh	r2, [r2, #0]
    259a:	4293      	cmp	r3, r2
    259c:	d02f      	beq.n	25fe <comms_usb_communication_routine+0xda>
            comms_usb_expected_packet_number = 0;
        }
        else
        {
            /* here we should implement in the future transfers in multiple chunks */
            comms_usb_arm_packet_receive();
    259e:	4b3a      	ldr	r3, [pc, #232]	; (2688 <comms_usb_communication_routine+0x164>)
    25a0:	4798      	blx	r3
    25a2:	e02b      	b.n	25fc <comms_usb_communication_routine+0xd8>
        if (((comms_usb_expect_flip_bit_state_set != FALSE) && (raw_hid_recv_buffer.byte0.flip_bit == 0)) || ((comms_usb_expect_flip_bit_state_set == FALSE) && (raw_hid_recv_buffer.byte0.flip_bit != 0)))
    25a4:	4b32      	ldr	r3, [pc, #200]	; (2670 <comms_usb_communication_routine+0x14c>)
    25a6:	781b      	ldrb	r3, [r3, #0]
    25a8:	2b7f      	cmp	r3, #127	; 0x7f
    25aa:	d858      	bhi.n	265e <comms_usb_communication_routine+0x13a>
        if ((comms_usb_expected_packet_number != 0) && (raw_hid_recv_buffer.byte1.packet_id != comms_usb_expected_packet_number))
    25ac:	4b32      	ldr	r3, [pc, #200]	; (2678 <comms_usb_communication_routine+0x154>)
    25ae:	881e      	ldrh	r6, [r3, #0]
    25b0:	2e00      	cmp	r6, #0
    25b2:	d0d0      	beq.n	2556 <comms_usb_communication_routine+0x32>
    25b4:	4b2e      	ldr	r3, [pc, #184]	; (2670 <comms_usb_communication_routine+0x14c>)
    25b6:	785b      	ldrb	r3, [r3, #1]
    25b8:	091b      	lsrs	r3, r3, #4
    25ba:	42b3      	cmp	r3, r6
    25bc:	d0cb      	beq.n	2556 <comms_usb_communication_routine+0x32>
            comms_usb_temp_mcu_message_fill_index = 0;
    25be:	2300      	movs	r3, #0
    25c0:	4a2c      	ldr	r2, [pc, #176]	; (2674 <comms_usb_communication_routine+0x150>)
    25c2:	8013      	strh	r3, [r2, #0]
            comms_usb_expected_packet_number = 0;
    25c4:	4a2c      	ldr	r2, [pc, #176]	; (2678 <comms_usb_communication_routine+0x154>)
    25c6:	8013      	strh	r3, [r2, #0]
            comms_usb_arm_packet_receive();
    25c8:	4b2f      	ldr	r3, [pc, #188]	; (2688 <comms_usb_communication_routine+0x164>)
    25ca:	4798      	blx	r3
            return;            
    25cc:	e016      	b.n	25fc <comms_usb_communication_routine+0xd8>
            comms_usb_total_expected_packets = raw_hid_recv_buffer.byte1.total_packets;
    25ce:	4b28      	ldr	r3, [pc, #160]	; (2670 <comms_usb_communication_routine+0x14c>)
    25d0:	785b      	ldrb	r3, [r3, #1]
    25d2:	071b      	lsls	r3, r3, #28
    25d4:	0f1b      	lsrs	r3, r3, #28
    25d6:	4a2b      	ldr	r2, [pc, #172]	; (2684 <comms_usb_communication_routine+0x160>)
    25d8:	8013      	strh	r3, [r2, #0]
            comms_usb_temp_mcu_message_fill_index = 0;
    25da:	2200      	movs	r2, #0
    25dc:	4b25      	ldr	r3, [pc, #148]	; (2674 <comms_usb_communication_routine+0x150>)
    25de:	801a      	strh	r2, [r3, #0]
            memset((void*)&comms_usb_temp_mcu_message_to_send, 0, sizeof(comms_usb_temp_mcu_message_to_send));
    25e0:	2288      	movs	r2, #136	; 0x88
    25e2:	0092      	lsls	r2, r2, #2
    25e4:	2100      	movs	r1, #0
    25e6:	4825      	ldr	r0, [pc, #148]	; (267c <comms_usb_communication_routine+0x158>)
    25e8:	4b28      	ldr	r3, [pc, #160]	; (268c <comms_usb_communication_routine+0x168>)
    25ea:	4798      	blx	r3
    25ec:	e7b8      	b.n	2560 <comms_usb_communication_routine+0x3c>
            comms_usb_temp_mcu_message_fill_index = 0;
    25ee:	2300      	movs	r3, #0
    25f0:	4a20      	ldr	r2, [pc, #128]	; (2674 <comms_usb_communication_routine+0x150>)
    25f2:	8013      	strh	r3, [r2, #0]
            comms_usb_expected_packet_number = 0;
    25f4:	4a20      	ldr	r2, [pc, #128]	; (2678 <comms_usb_communication_routine+0x154>)
    25f6:	8013      	strh	r3, [r2, #0]
            comms_usb_arm_packet_receive();
    25f8:	4b23      	ldr	r3, [pc, #140]	; (2688 <comms_usb_communication_routine+0x164>)
    25fa:	4798      	blx	r3
        }
    }
}
    25fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if (comms_usb_expect_flip_bit_state_set == FALSE)
    25fe:	4b1b      	ldr	r3, [pc, #108]	; (266c <comms_usb_communication_routine+0x148>)
    2600:	681b      	ldr	r3, [r3, #0]
    2602:	2b00      	cmp	r3, #0
    2604:	d119      	bne.n	263a <comms_usb_communication_routine+0x116>
                comms_usb_expect_flip_bit_state_set = TRUE;
    2606:	2201      	movs	r2, #1
    2608:	4b18      	ldr	r3, [pc, #96]	; (266c <comms_usb_communication_routine+0x148>)
    260a:	601a      	str	r2, [r3, #0]
            if (raw_hid_recv_buffer.byte0.ack_flag_or_req != 0)
    260c:	4b18      	ldr	r3, [pc, #96]	; (2670 <comms_usb_communication_routine+0x14c>)
    260e:	781b      	ldrb	r3, [r3, #0]
    2610:	065b      	lsls	r3, r3, #25
    2612:	d416      	bmi.n	2642 <comms_usb_communication_routine+0x11e>
            comms_usb_temp_mcu_message_to_send.payload_length1 = comms_usb_temp_mcu_message_fill_index;
    2614:	4819      	ldr	r0, [pc, #100]	; (267c <comms_usb_communication_routine+0x158>)
    2616:	4c17      	ldr	r4, [pc, #92]	; (2674 <comms_usb_communication_routine+0x150>)
    2618:	8823      	ldrh	r3, [r4, #0]
    261a:	8043      	strh	r3, [r0, #2]
            comms_main_mcu_send_message(&comms_usb_temp_mcu_message_to_send, (uint16_t)sizeof(comms_usb_temp_mcu_message_to_send));
    261c:	2188      	movs	r1, #136	; 0x88
    261e:	0089      	lsls	r1, r1, #2
    2620:	4b1b      	ldr	r3, [pc, #108]	; (2690 <comms_usb_communication_routine+0x16c>)
    2622:	4798      	blx	r3
            comms_usb_arm_packet_receive();
    2624:	4b18      	ldr	r3, [pc, #96]	; (2688 <comms_usb_communication_routine+0x164>)
    2626:	4798      	blx	r3
            dbg_mcu_hid_msg_sent++;
    2628:	4a1a      	ldr	r2, [pc, #104]	; (2694 <comms_usb_communication_routine+0x170>)
    262a:	8813      	ldrh	r3, [r2, #0]
    262c:	3301      	adds	r3, #1
    262e:	8013      	strh	r3, [r2, #0]
            comms_usb_temp_mcu_message_fill_index = 0;
    2630:	2300      	movs	r3, #0
    2632:	8023      	strh	r3, [r4, #0]
            comms_usb_expected_packet_number = 0;
    2634:	4a10      	ldr	r2, [pc, #64]	; (2678 <comms_usb_communication_routine+0x154>)
    2636:	8013      	strh	r3, [r2, #0]
    2638:	e7e0      	b.n	25fc <comms_usb_communication_routine+0xd8>
                comms_usb_expect_flip_bit_state_set = FALSE;
    263a:	2200      	movs	r2, #0
    263c:	4b0b      	ldr	r3, [pc, #44]	; (266c <comms_usb_communication_routine+0x148>)
    263e:	601a      	str	r2, [r3, #0]
    2640:	e7e4      	b.n	260c <comms_usb_communication_routine+0xe8>
                memcpy((void*)&raw_hid_send_buffer, (void*)&raw_hid_recv_buffer, sizeof(raw_hid_send_buffer));
    2642:	4c15      	ldr	r4, [pc, #84]	; (2698 <comms_usb_communication_routine+0x174>)
    2644:	2240      	movs	r2, #64	; 0x40
    2646:	490a      	ldr	r1, [pc, #40]	; (2670 <comms_usb_communication_routine+0x14c>)
    2648:	0020      	movs	r0, r4
    264a:	4b0d      	ldr	r3, [pc, #52]	; (2680 <comms_usb_communication_routine+0x15c>)
    264c:	4798      	blx	r3
                comms_usb_send_raw_hid_packet(&raw_hid_send_buffer, TRUE, comms_usb_raw_hid_packet_receive_length);
    264e:	4b13      	ldr	r3, [pc, #76]	; (269c <comms_usb_communication_routine+0x178>)
    2650:	681a      	ldr	r2, [r3, #0]
    2652:	b292      	uxth	r2, r2
    2654:	2101      	movs	r1, #1
    2656:	0020      	movs	r0, r4
    2658:	4b11      	ldr	r3, [pc, #68]	; (26a0 <comms_usb_communication_routine+0x17c>)
    265a:	4798      	blx	r3
    265c:	e7da      	b.n	2614 <comms_usb_communication_routine+0xf0>
                comms_usb_expect_flip_bit_state_set = TRUE;
    265e:	2201      	movs	r2, #1
    2660:	4b02      	ldr	r3, [pc, #8]	; (266c <comms_usb_communication_routine+0x148>)
    2662:	601a      	str	r2, [r3, #0]
    2664:	e771      	b.n	254a <comms_usb_communication_routine+0x26>
    2666:	46c0      	nop			; (mov r8, r8)
    2668:	20000118 	.word	0x20000118
    266c:	20000108 	.word	0x20000108
    2670:	20000124 	.word	0x20000124
    2674:	2000011c 	.word	0x2000011c
    2678:	2000010c 	.word	0x2000010c
    267c:	20000564 	.word	0x20000564
    2680:	000039ed 	.word	0x000039ed
    2684:	20000560 	.word	0x20000560
    2688:	000023b1 	.word	0x000023b1
    268c:	000039ff 	.word	0x000039ff
    2690:	000021fd 	.word	0x000021fd
    2694:	20000120 	.word	0x20000120
    2698:	20000164 	.word	0x20000164
    269c:	20000114 	.word	0x20000114
    26a0:	000023c9 	.word	0x000023c9

000026a4 <dma_init>:

/*! \fn     dma_init(void)
*   \brief  Initialize DMA controller that will be used later
*/
void dma_init(void)
{
    26a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    26a6:	46d6      	mov	lr, sl
    26a8:	464f      	mov	r7, r9
    26aa:	4646      	mov	r6, r8
    26ac:	b5c0      	push	{r6, r7, lr}
    /* Setup DMA controller */
    DMAC_CTRL_Type dmac_ctrl_reg;
    DMAC->BASEADDR.reg = (uint32_t)&dma_descriptors[0];                                     // Base descriptor
    26ae:	4b2d      	ldr	r3, [pc, #180]	; (2764 <dma_init+0xc0>)
    26b0:	4a2d      	ldr	r2, [pc, #180]	; (2768 <dma_init+0xc4>)
    26b2:	6353      	str	r3, [r2, #52]	; 0x34
    DMAC->WRBADDR.reg = (uint32_t)&dma_writeback_descriptors[0];                            // Write back descriptor
    26b4:	492d      	ldr	r1, [pc, #180]	; (276c <dma_init+0xc8>)
    26b6:	6391      	str	r1, [r2, #56]	; 0x38
    dmac_ctrl_reg.reg = DMAC_CTRL_DMAENABLE;                                                // Enable dma
    26b8:	2602      	movs	r6, #2
    dmac_ctrl_reg.bit.LVLEN0 = 1;                                                           // Enable priority level 0
    dmac_ctrl_reg.bit.LVLEN1 = 1;                                                           // Enable priority level 1
    dmac_ctrl_reg.bit.LVLEN2 = 1;                                                           // Enable priority level 2
    dmac_ctrl_reg.bit.LVLEN3 = 1;                                                           // Enable priority level 3
    26ba:	492d      	ldr	r1, [pc, #180]	; (2770 <dma_init+0xcc>)
    DMAC->CTRL = dmac_ctrl_reg;                                                             // Write DMA control register
    26bc:	8011      	strh	r1, [r2, #0]
    //DMAC->DBGCTRL.bit.DBGRUN = 1;                                                         // Normal operation during debugging
    
    /* DMA QOS: elevate to medium priority */
    DMAC_QOSCTRL_Type dma_qos_ctrl_reg;                                                     // Temporary register
    dma_qos_ctrl_reg.reg = 0;                                                               // Clear temp register
    26be:	2400      	movs	r4, #0
    dma_qos_ctrl_reg.bit.DQOS = DMAC_QOSCTRL_WRBQOS_MEDIUM_Val;                             // Medium QOS for writeback
    dma_qos_ctrl_reg.bit.FQOS = DMAC_QOSCTRL_WRBQOS_MEDIUM_Val;                             // Medium QOS for fetch
    dma_qos_ctrl_reg.bit.WRBQOS = DMAC_QOSCTRL_WRBQOS_MEDIUM_Val;                           // Medium QOS for data
    26c0:	212a      	movs	r1, #42	; 0x2a
    DMAC->QOSCTRL = dma_qos_ctrl_reg;                                                       // Write register
    26c2:	7391      	strb	r1, [r2, #14]
    
    /* Enable round robin for all levels */
    DMAC_PRICTRL0_Type dmac_prictrl_reg;                                                    // Temporary register
    dmac_prictrl_reg.reg = 0;                                                               // Clear temp register
    dmac_prictrl_reg.bit.LVLPRI0 = 1;                                                       // Enable round robin for level 0
    26c4:	3929      	subs	r1, #41	; 0x29
    26c6:	4689      	mov	r9, r1
    dmac_prictrl_reg.bit.LVLPRI1 = 1;                                                       // Enable round robin for level 1
    dmac_prictrl_reg.bit.LVLPRI2 = 1;                                                       // Enable round robin for level 2
    dmac_prictrl_reg.bit.LVLPRI3 = 1;                                                       // Enable round robin for level 3
    26c8:	492a      	ldr	r1, [pc, #168]	; (2774 <dma_init+0xd0>)
    DMAC->PRICTRL0 = dmac_prictrl_reg;                                                      // Write register
    26ca:	6151      	str	r1, [r2, #20]

    /* Setup transfer descriptor for aux comms TX */
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCTRL.reg = DMAC_BTCTRL_VALID;                      // Valid descriptor
    26cc:	4649      	mov	r1, r9
    26ce:	8219      	strh	r1, [r3, #16]
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCTRL.bit.STEPSIZE = DMAC_BTCTRL_STEPSIZE_X1_Val;   // 1 byte address increment
    26d0:	8a19      	ldrh	r1, [r3, #16]
    26d2:	04c9      	lsls	r1, r1, #19
    26d4:	0cc9      	lsrs	r1, r1, #19
    26d6:	8219      	strh	r1, [r3, #16]
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCTRL.bit.STEPSEL = DMAC_BTCTRL_STEPSEL_SRC_Val;    // Step selection for source
    26d8:	8a18      	ldrh	r0, [r3, #16]
    26da:	2180      	movs	r1, #128	; 0x80
    26dc:	0149      	lsls	r1, r1, #5
    26de:	4301      	orrs	r1, r0
    26e0:	8219      	strh	r1, [r3, #16]
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCTRL.bit.SRCINC = 1;                               // Source Address Increment is enabled.
    26e2:	8a18      	ldrh	r0, [r3, #16]
    26e4:	2180      	movs	r1, #128	; 0x80
    26e6:	00c9      	lsls	r1, r1, #3
    26e8:	4301      	orrs	r1, r0
    26ea:	8219      	strh	r1, [r3, #16]
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCTRL.bit.BEATSIZE = DMAC_BTCTRL_BEATSIZE_BYTE_Val; // Byte data transfer
    26ec:	8a18      	ldrh	r0, [r3, #16]
    26ee:	4922      	ldr	r1, [pc, #136]	; (2778 <dma_init+0xd4>)
    26f0:	468a      	mov	sl, r1
    26f2:	4008      	ands	r0, r1
    26f4:	8218      	strh	r0, [r3, #16]
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCTRL.bit.BLOCKACT = DMAC_BTCTRL_BLOCKACT_INT_Val;  // Once data block is transferred, generate interrupt
    26f6:	8a18      	ldrh	r0, [r3, #16]
    26f8:	2518      	movs	r5, #24
    26fa:	46a8      	mov	r8, r5
    26fc:	43a8      	bics	r0, r5
    26fe:	2508      	movs	r5, #8
    2700:	46ac      	mov	ip, r5
    2702:	4665      	mov	r5, ip
    2704:	4328      	orrs	r0, r5
    2706:	8218      	strh	r0, [r3, #16]
    dma_descriptors[DMA_DESCID_TX_COMMS].DESCADDR.reg = 0;                                    // No next descriptor address
    2708:	61dc      	str	r4, [r3, #28]
    
    /* Setup DMA channel */
    DMAC->CHID.reg = DMAC_CHID_ID(DMA_DESCID_TX_COMMS);                                     // Select channel
    270a:	273f      	movs	r7, #63	; 0x3f
    270c:	2001      	movs	r0, #1
    270e:	55d0      	strb	r0, [r2, r7]
    DMAC_CHCTRLB_Type dma_chctrlb_reg;                                                      // Temp register
    dma_chctrlb_reg.reg = 0;                                                                // Clear temp register
    dma_chctrlb_reg.bit.LVL = 1;                                                            // Priority level
    dma_chctrlb_reg.bit.TRIGACT = DMAC_CHCTRLB_TRIGACT_BEAT_Val;                            // One trigger required for each beat transfer
    dma_chctrlb_reg.bit.TRIGSRC = AUX_MCU_SERCOM_TXTRIG;                                    // Select TX trigger
    2710:	481a      	ldr	r0, [pc, #104]	; (277c <dma_init+0xd8>)
    DMAC->CHCTRLB = dma_chctrlb_reg;                                                        // Write register
    2712:	6450      	str	r0, [r2, #68]	; 0x44
    DMAC->CHINTENSET.reg = DMAC_CHINTENSET_TCMPL;                                           // Enable channel transfer complete interrupt
    2714:	254d      	movs	r5, #77	; 0x4d
    2716:	5556      	strb	r6, [r2, r5]

    /* Setup transfer descriptor for aux MCU comms RX */
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCTRL.reg = DMAC_BTCTRL_VALID;                     // Valid descriptor
    2718:	4648      	mov	r0, r9
    271a:	8018      	strh	r0, [r3, #0]
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCTRL.bit.STEPSIZE = DMAC_BTCTRL_STEPSIZE_X1_Val;  // 1 byte address increment
    271c:	8818      	ldrh	r0, [r3, #0]
    271e:	04c0      	lsls	r0, r0, #19
    2720:	0cc0      	lsrs	r0, r0, #19
    2722:	8018      	strh	r0, [r3, #0]
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCTRL.bit.STEPSEL = DMAC_BTCTRL_STEPSEL_DST_Val;   // Step selection for destination
    2724:	8818      	ldrh	r0, [r3, #0]
    2726:	4916      	ldr	r1, [pc, #88]	; (2780 <dma_init+0xdc>)
    2728:	4008      	ands	r0, r1
    272a:	8018      	strh	r0, [r3, #0]
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCTRL.bit.DSTINC = 1;                              // Destination Address Increment is enabled.
    272c:	8819      	ldrh	r1, [r3, #0]
    272e:	2080      	movs	r0, #128	; 0x80
    2730:	0100      	lsls	r0, r0, #4
    2732:	4308      	orrs	r0, r1
    2734:	8018      	strh	r0, [r3, #0]
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCTRL.bit.BEATSIZE = DMAC_BTCTRL_BEATSIZE_BYTE_Val;// Byte data transfer
    2736:	8818      	ldrh	r0, [r3, #0]
    2738:	4651      	mov	r1, sl
    273a:	4001      	ands	r1, r0
    273c:	8019      	strh	r1, [r3, #0]
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCTRL.bit.BLOCKACT = DMAC_BTCTRL_BLOCKACT_INT_Val; // Once data block is transferred, generate interrupt
    273e:	8819      	ldrh	r1, [r3, #0]
    2740:	4640      	mov	r0, r8
    2742:	4381      	bics	r1, r0
    2744:	4660      	mov	r0, ip
    2746:	4301      	orrs	r1, r0
    2748:	8019      	strh	r1, [r3, #0]
    dma_descriptors[DMA_DESCID_RX_COMMS].DESCADDR.reg = 0;                                   // No next descriptor
    274a:	60dc      	str	r4, [r3, #12]
    
    /* Setup DMA channel */
    DMAC->CHID.reg = DMAC_CHID_ID(DMA_DESCID_RX_COMMS);                                     // Select channel
    274c:	55d4      	strb	r4, [r2, r7]
    dma_chctrlb_reg.reg = 0;                                                                // Clear temp register
    dma_chctrlb_reg.bit.LVL = 3;                                                            // Priority level
    dma_chctrlb_reg.bit.TRIGACT = DMAC_CHCTRLB_TRIGACT_BEAT_Val;                            // One trigger required for each beat transfer
    dma_chctrlb_reg.bit.TRIGSRC = AUX_MCU_SERCOM_RXTRIG;                                    // Select RX trigger
    274e:	4b0d      	ldr	r3, [pc, #52]	; (2784 <dma_init+0xe0>)
    DMAC->CHCTRLB = dma_chctrlb_reg;                                                        // Write register
    2750:	6453      	str	r3, [r2, #68]	; 0x44
    DMAC->CHINTENSET.reg = DMAC_CHINTENSET_TCMPL;                                           // Enable channel transfer complete interrupt
    2752:	5556      	strb	r6, [r2, r5]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    2754:	2240      	movs	r2, #64	; 0x40
    2756:	4b0c      	ldr	r3, [pc, #48]	; (2788 <dma_init+0xe4>)
    2758:	601a      	str	r2, [r3, #0]

    /* Enable IRQ */
    NVIC_EnableIRQ(DMAC_IRQn);
}
    275a:	bc1c      	pop	{r2, r3, r4}
    275c:	4690      	mov	r8, r2
    275e:	4699      	mov	r9, r3
    2760:	46a2      	mov	sl, r4
    2762:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2764:	20001080 	.word	0x20001080
    2768:	41004800 	.word	0x41004800
    276c:	20000df0 	.word	0x20000df0
    2770:	00000f02 	.word	0x00000f02
    2774:	01010101 	.word	0x01010101
    2778:	fffffcff 	.word	0xfffffcff
    277c:	00800820 	.word	0x00800820
    2780:	ffffefff 	.word	0xffffefff
    2784:	00800760 	.word	0x00800760
    2788:	e000e100 	.word	0xe000e100

0000278c <dma_main_mcu_get_remaining_bytes_for_rx_transfer>:
*   \return The number of remaining bytes
*/
uint16_t dma_main_mcu_get_remaining_bytes_for_rx_transfer(void)
{
    /* Check for active channel */
    DMAC_ACTIVE_Type active_reg_copy = DMAC->ACTIVE;
    278c:	4b06      	ldr	r3, [pc, #24]	; (27a8 <dma_main_mcu_get_remaining_bytes_for_rx_transfer+0x1c>)
    278e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2790:	0c18      	lsrs	r0, r3, #16
    if (active_reg_copy.bit.ID == DMA_DESCID_RX_COMMS && active_reg_copy.bit.ABUSY != 0)
    2792:	041b      	lsls	r3, r3, #16
    2794:	0e1b      	lsrs	r3, r3, #24
    2796:	2260      	movs	r2, #96	; 0x60
    2798:	4393      	bics	r3, r2
    279a:	2b80      	cmp	r3, #128	; 0x80
    279c:	d002      	beq.n	27a4 <dma_main_mcu_get_remaining_bytes_for_rx_transfer+0x18>
    {
        return active_reg_copy.bit.BTCNT;
    }
    else
    {
        return dma_writeback_descriptors[DMA_DESCID_RX_COMMS].BTCNT.reg;
    279e:	4b03      	ldr	r3, [pc, #12]	; (27ac <dma_main_mcu_get_remaining_bytes_for_rx_transfer+0x20>)
    27a0:	8858      	ldrh	r0, [r3, #2]
    27a2:	b280      	uxth	r0, r0
    }
}
    27a4:	4770      	bx	lr
    27a6:	46c0      	nop			; (mov r8, r8)
    27a8:	41004800 	.word	0x41004800
    27ac:	20000df0 	.word	0x20000df0

000027b0 <dma_main_mcu_init_tx_transfer>:
*   \param  spi_data_p  Pointer to the SPI data register
*   \param  datap       Pointer to the data
*   \param  size        Number of bytes to transfer
*/
void dma_main_mcu_init_tx_transfer(void* spi_data_p, void* datap, uint16_t size)
{
    27b0:	b570      	push	{r4, r5, r6, lr}
    27b2:	0006      	movs	r6, r0
    27b4:	000c      	movs	r4, r1
    27b6:	0015      	movs	r5, r2
    /* Wait for previous transfer to be done */
    while (dma_main_mcu_packet_sent == FALSE);
    27b8:	4a0b      	ldr	r2, [pc, #44]	; (27e8 <dma_main_mcu_init_tx_transfer+0x38>)
    27ba:	6813      	ldr	r3, [r2, #0]
    27bc:	2b00      	cmp	r3, #0
    27be:	d0fc      	beq.n	27ba <dma_main_mcu_init_tx_transfer+0xa>
    
    cpu_irq_enter_critical();
    27c0:	4b0a      	ldr	r3, [pc, #40]	; (27ec <dma_main_mcu_init_tx_transfer+0x3c>)
    27c2:	4798      	blx	r3
    
    /* Set bool */
    dma_main_mcu_packet_sent = FALSE;
    27c4:	2200      	movs	r2, #0
    27c6:	4b08      	ldr	r3, [pc, #32]	; (27e8 <dma_main_mcu_init_tx_transfer+0x38>)
    27c8:	601a      	str	r2, [r3, #0]
    
    /* Setup transfer size */
    dma_descriptors[DMA_DESCID_TX_COMMS].BTCNT.bit.BTCNT = (uint16_t)size;
    27ca:	4b09      	ldr	r3, [pc, #36]	; (27f0 <dma_main_mcu_init_tx_transfer+0x40>)
    27cc:	825d      	strh	r5, [r3, #18]
    /* Source address: DATA register from SPI */
    dma_descriptors[DMA_DESCID_TX_COMMS].DSTADDR.reg = (uint32_t)spi_data_p;
    27ce:	619e      	str	r6, [r3, #24]
    /* Destination address: given value */
    dma_descriptors[DMA_DESCID_TX_COMMS].SRCADDR.reg = (uint32_t)datap + size;
    27d0:	1964      	adds	r4, r4, r5
    27d2:	615c      	str	r4, [r3, #20]
    
    /* Resume DMA channel operation */
    DMAC->CHID.reg= DMAC_CHID_ID(DMA_DESCID_TX_COMMS);
    27d4:	4b07      	ldr	r3, [pc, #28]	; (27f4 <dma_main_mcu_init_tx_transfer+0x44>)
    27d6:	2101      	movs	r1, #1
    27d8:	323f      	adds	r2, #63	; 0x3f
    27da:	5499      	strb	r1, [r3, r2]
    DMAC->CHCTRLA.reg = DMAC_CHCTRLA_ENABLE;
    27dc:	3101      	adds	r1, #1
    27de:	3201      	adds	r2, #1
    27e0:	5499      	strb	r1, [r3, r2]
    
    cpu_irq_leave_critical();
    27e2:	4b05      	ldr	r3, [pc, #20]	; (27f8 <dma_main_mcu_init_tx_transfer+0x48>)
    27e4:	4798      	blx	r3
}
    27e6:	bd70      	pop	{r4, r5, r6, pc}
    27e8:	20000000 	.word	0x20000000
    27ec:	000036a1 	.word	0x000036a1
    27f0:	20001080 	.word	0x20001080
    27f4:	41004800 	.word	0x41004800
    27f8:	000036e1 	.word	0x000036e1

000027fc <dma_main_mcu_init_rx_transfer>:

/*! \fn     dma_main_mcu_init_rx_transfer(void)
*   \brief  Initialize a DMA transfer from the main MCU
*/
void dma_main_mcu_init_rx_transfer(void)
{
    27fc:	b510      	push	{r4, lr}
    cpu_irq_enter_critical();
    27fe:	4b0c      	ldr	r3, [pc, #48]	; (2830 <dma_main_mcu_init_rx_transfer+0x34>)
    2800:	4798      	blx	r3
    
    /* Setup transfer size */
    dma_descriptors[DMA_DESCID_RX_COMMS].BTCNT.bit.BTCNT = (uint16_t)sizeof(dma_main_mcu_temp_rcv_message);
    2802:	4b0c      	ldr	r3, [pc, #48]	; (2834 <dma_main_mcu_init_rx_transfer+0x38>)
    2804:	2288      	movs	r2, #136	; 0x88
    2806:	0092      	lsls	r2, r2, #2
    2808:	805a      	strh	r2, [r3, #2]
    /* Source address: DATA register from SPI */
    dma_descriptors[DMA_DESCID_RX_COMMS].DSTADDR.reg = (uint32_t)(&dma_main_mcu_temp_rcv_message) + sizeof(dma_main_mcu_temp_rcv_message);
    280a:	4a0b      	ldr	r2, [pc, #44]	; (2838 <dma_main_mcu_init_rx_transfer+0x3c>)
    280c:	2188      	movs	r1, #136	; 0x88
    280e:	0089      	lsls	r1, r1, #2
    2810:	468c      	mov	ip, r1
    2812:	4462      	add	r2, ip
    2814:	609a      	str	r2, [r3, #8]
    /* Destination address: given value */
    dma_descriptors[DMA_DESCID_RX_COMMS].SRCADDR.reg = (uint32_t)((void*)&AUXMCU_SERCOM->USART.DATA.reg);
    2816:	4a09      	ldr	r2, [pc, #36]	; (283c <dma_main_mcu_init_rx_transfer+0x40>)
    2818:	605a      	str	r2, [r3, #4]
    
    /* Resume DMA channel operation */
    DMAC->CHID.reg= DMAC_CHID_ID(DMA_DESCID_RX_COMMS);
    281a:	4b09      	ldr	r3, [pc, #36]	; (2840 <dma_main_mcu_init_rx_transfer+0x44>)
    281c:	2100      	movs	r1, #0
    281e:	223f      	movs	r2, #63	; 0x3f
    2820:	5499      	strb	r1, [r3, r2]
    DMAC->CHCTRLA.reg = DMAC_CHCTRLA_ENABLE;
    2822:	3102      	adds	r1, #2
    2824:	3201      	adds	r2, #1
    2826:	5499      	strb	r1, [r3, r2]
    
    cpu_irq_leave_critical();
    2828:	4b06      	ldr	r3, [pc, #24]	; (2844 <dma_main_mcu_init_rx_transfer+0x48>)
    282a:	4798      	blx	r3
}
    282c:	bd10      	pop	{r4, pc}
    282e:	46c0      	nop			; (mov r8, r8)
    2830:	000036a1 	.word	0x000036a1
    2834:	20001080 	.word	0x20001080
    2838:	20000790 	.word	0x20000790
    283c:	42001428 	.word	0x42001428
    2840:	41004800 	.word	0x41004800
    2844:	000036e1 	.word	0x000036e1

00002848 <DMAC_Handler>:
{    
    2848:	b510      	push	{r4, lr}
    DMAC->CHID.reg = DMAC_CHID_ID(DMA_DESCID_RX_COMMS);
    284a:	4b24      	ldr	r3, [pc, #144]	; (28dc <DMAC_Handler+0x94>)
    284c:	2100      	movs	r1, #0
    284e:	223f      	movs	r2, #63	; 0x3f
    2850:	5499      	strb	r1, [r3, r2]
    if ((DMAC->CHINTFLAG.reg & DMAC_CHINTFLAG_TCMPL) != 0)
    2852:	320f      	adds	r2, #15
    2854:	5c9b      	ldrb	r3, [r3, r2]
    2856:	079b      	lsls	r3, r3, #30
    2858:	d516      	bpl.n	2888 <DMAC_Handler+0x40>
        dma_aux_mcu_packet_received = TRUE;
    285a:	3a4d      	subs	r2, #77	; 0x4d
    285c:	4b20      	ldr	r3, [pc, #128]	; (28e0 <DMAC_Handler+0x98>)
    285e:	601a      	str	r2, [r3, #0]
        DMAC->CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    2860:	3102      	adds	r1, #2
    2862:	234e      	movs	r3, #78	; 0x4e
    2864:	4a1d      	ldr	r2, [pc, #116]	; (28dc <DMAC_Handler+0x94>)
    2866:	54d1      	strb	r1, [r2, r3]
        if (dma_main_mcu_temp_rcv_message.message_type == AUX_MCU_MSG_TYPE_USB)
    2868:	4b1e      	ldr	r3, [pc, #120]	; (28e4 <DMAC_Handler+0x9c>)
    286a:	881b      	ldrh	r3, [r3, #0]
    286c:	b29b      	uxth	r3, r3
    286e:	2b00      	cmp	r3, #0
    2870:	d11a      	bne.n	28a8 <DMAC_Handler+0x60>
            memcpy((void*)&dma_main_mcu_usb_rcv_message, (void*)&dma_main_mcu_temp_rcv_message, sizeof(dma_main_mcu_temp_rcv_message));
    2872:	2288      	movs	r2, #136	; 0x88
    2874:	0092      	lsls	r2, r2, #2
    2876:	491b      	ldr	r1, [pc, #108]	; (28e4 <DMAC_Handler+0x9c>)
    2878:	481b      	ldr	r0, [pc, #108]	; (28e8 <DMAC_Handler+0xa0>)
    287a:	4b1c      	ldr	r3, [pc, #112]	; (28ec <DMAC_Handler+0xa4>)
    287c:	4798      	blx	r3
            dma_main_mcu_usb_msg_received = TRUE;
    287e:	2201      	movs	r2, #1
    2880:	4b1b      	ldr	r3, [pc, #108]	; (28f0 <DMAC_Handler+0xa8>)
    2882:	601a      	str	r2, [r3, #0]
        dma_main_mcu_init_rx_transfer();
    2884:	4b1b      	ldr	r3, [pc, #108]	; (28f4 <DMAC_Handler+0xac>)
    2886:	4798      	blx	r3
    DMAC->CHID.reg = DMAC_CHID_ID(DMA_DESCID_TX_COMMS);
    2888:	4b14      	ldr	r3, [pc, #80]	; (28dc <DMAC_Handler+0x94>)
    288a:	2101      	movs	r1, #1
    288c:	223f      	movs	r2, #63	; 0x3f
    288e:	5499      	strb	r1, [r3, r2]
    if ((DMAC->CHINTFLAG.reg & DMAC_CHINTFLAG_TCMPL) != 0)
    2890:	320f      	adds	r2, #15
    2892:	5c9b      	ldrb	r3, [r3, r2]
    2894:	079b      	lsls	r3, r3, #30
    2896:	d506      	bpl.n	28a6 <DMAC_Handler+0x5e>
        dma_main_mcu_packet_sent = TRUE;
    2898:	3a4d      	subs	r2, #77	; 0x4d
    289a:	4b17      	ldr	r3, [pc, #92]	; (28f8 <DMAC_Handler+0xb0>)
    289c:	601a      	str	r2, [r3, #0]
        DMAC->CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    289e:	3101      	adds	r1, #1
    28a0:	234e      	movs	r3, #78	; 0x4e
    28a2:	4a0e      	ldr	r2, [pc, #56]	; (28dc <DMAC_Handler+0x94>)
    28a4:	54d1      	strb	r1, [r2, r3]
}
    28a6:	bd10      	pop	{r4, pc}
        else if (dma_main_mcu_temp_rcv_message.message_type == AUX_MCU_MSG_TYPE_BLE)
    28a8:	4b0e      	ldr	r3, [pc, #56]	; (28e4 <DMAC_Handler+0x9c>)
    28aa:	881b      	ldrh	r3, [r3, #0]
    28ac:	b29b      	uxth	r3, r3
    28ae:	2b01      	cmp	r3, #1
    28b0:	d009      	beq.n	28c6 <DMAC_Handler+0x7e>
            memcpy((void*)&dma_main_mcu_other_message, (void*)&dma_main_mcu_temp_rcv_message, sizeof(dma_main_mcu_temp_rcv_message));
    28b2:	2288      	movs	r2, #136	; 0x88
    28b4:	0092      	lsls	r2, r2, #2
    28b6:	490b      	ldr	r1, [pc, #44]	; (28e4 <DMAC_Handler+0x9c>)
    28b8:	4810      	ldr	r0, [pc, #64]	; (28fc <DMAC_Handler+0xb4>)
    28ba:	4b0c      	ldr	r3, [pc, #48]	; (28ec <DMAC_Handler+0xa4>)
    28bc:	4798      	blx	r3
            dma_main_mcu_other_msg_received = TRUE;        
    28be:	2201      	movs	r2, #1
    28c0:	4b0f      	ldr	r3, [pc, #60]	; (2900 <DMAC_Handler+0xb8>)
    28c2:	601a      	str	r2, [r3, #0]
    28c4:	e7de      	b.n	2884 <DMAC_Handler+0x3c>
            memcpy((void*)&dma_main_mcu_ble_rcv_message, (void*)&dma_main_mcu_temp_rcv_message, sizeof(dma_main_mcu_temp_rcv_message));
    28c6:	2288      	movs	r2, #136	; 0x88
    28c8:	0092      	lsls	r2, r2, #2
    28ca:	4906      	ldr	r1, [pc, #24]	; (28e4 <DMAC_Handler+0x9c>)
    28cc:	480d      	ldr	r0, [pc, #52]	; (2904 <DMAC_Handler+0xbc>)
    28ce:	4b07      	ldr	r3, [pc, #28]	; (28ec <DMAC_Handler+0xa4>)
    28d0:	4798      	blx	r3
            dma_main_mcu_ble_msg_received = TRUE;
    28d2:	2201      	movs	r2, #1
    28d4:	4b0c      	ldr	r3, [pc, #48]	; (2908 <DMAC_Handler+0xc0>)
    28d6:	601a      	str	r2, [r3, #0]
    28d8:	e7d4      	b.n	2884 <DMAC_Handler+0x3c>
    28da:	46c0      	nop			; (mov r8, r8)
    28dc:	41004800 	.word	0x41004800
    28e0:	200001a4 	.word	0x200001a4
    28e4:	20000790 	.word	0x20000790
    28e8:	200009b0 	.word	0x200009b0
    28ec:	000039ed 	.word	0x000039ed
    28f0:	200001b0 	.word	0x200001b0
    28f4:	000027fd 	.word	0x000027fd
    28f8:	20000000 	.word	0x20000000
    28fc:	20000e60 	.word	0x20000e60
    2900:	200001ac 	.word	0x200001ac
    2904:	20000bd0 	.word	0x20000bd0
    2908:	200001a8 	.word	0x200001a8

0000290c <platform_io_init_aux_comms>:

/*! \fn     platform_io_init_aux_comms_ports(void)
*   \brief  Initialize the ports used for communication with aux MCU
*/
void platform_io_init_aux_comms(void)
{
    290c:	b510      	push	{r4, lr}
    /* Port init */
    PORT->Group[AUX_MCU_NOCOMMS_GROUP].DIRCLR.reg = AUX_MCU_NOCOMMS_MASK;                                   // No comms as input
    290e:	4b22      	ldr	r3, [pc, #136]	; (2998 <platform_io_init_aux_comms+0x8c>)
    2910:	2280      	movs	r2, #128	; 0x80
    2912:	02d2      	lsls	r2, r2, #11
    2914:	605a      	str	r2, [r3, #4]
    PORT->Group[AUX_MCU_NOCOMMS_GROUP].PINCFG[AUX_MCU_NOCOMMS_PINID].bit.INEN = 1;                          // No comms as input
    2916:	2252      	movs	r2, #82	; 0x52
    2918:	5c99      	ldrb	r1, [r3, r2]
    291a:	2002      	movs	r0, #2
    291c:	4301      	orrs	r1, r0
    291e:	5499      	strb	r1, [r3, r2]
    PORT->Group[AUX_MCU_NOCOMMS_GROUP].PINCFG[AUX_MCU_NOCOMMS_PINID].bit.PMUXEN = 0;                        // No comms as input
    2920:	5c99      	ldrb	r1, [r3, r2]
    2922:	2001      	movs	r0, #1
    2924:	4381      	bics	r1, r0
    2926:	5499      	strb	r1, [r3, r2]
    PORT->Group[AUX_MCU_RX_GROUP].PINCFG[AUX_MCU_RX_PINID].bit.PMUXEN = 1;                                  // Enable peripheral multiplexer
    2928:	3a01      	subs	r2, #1
    292a:	5c99      	ldrb	r1, [r3, r2]
    292c:	2401      	movs	r4, #1
    292e:	4321      	orrs	r1, r4
    2930:	5499      	strb	r1, [r3, r2]
    PORT->Group[AUX_MCU_RX_GROUP].PMUX[AUX_MCU_RX_PINID/2].bit.AUX_MCU_RX_PMUXREGID = AUX_MCU_RX_PMUX_ID;   // AUX MCU RX, MAIN MCU TX
    2932:	2138      	movs	r1, #56	; 0x38
    2934:	5c58      	ldrb	r0, [r3, r1]
    2936:	3a42      	subs	r2, #66	; 0x42
    2938:	4002      	ands	r2, r0
    293a:	2030      	movs	r0, #48	; 0x30
    293c:	4302      	orrs	r2, r0
    293e:	545a      	strb	r2, [r3, r1]
    PORT->Group[AUX_MCU_TX_GROUP].PINCFG[AUX_MCU_TX_PINID].bit.PMUXEN = 1;                                  // Enable peripheral multiplexer
    2940:	2050      	movs	r0, #80	; 0x50
    2942:	5c1a      	ldrb	r2, [r3, r0]
    2944:	4322      	orrs	r2, r4
    2946:	541a      	strb	r2, [r3, r0]
    PORT->Group[AUX_MCU_TX_GROUP].PMUX[AUX_MCU_TX_PINID/2].bit.AUX_MCU_TX_PMUXREGID = AUX_MCU_TX_PMUX_ID;   // AUX MCU TX, MAIN MCU RX
    2948:	5c5a      	ldrb	r2, [r3, r1]
    294a:	3841      	subs	r0, #65	; 0x41
    294c:	4382      	bics	r2, r0
    294e:	2003      	movs	r0, #3
    2950:	4302      	orrs	r2, r0
    2952:	545a      	strb	r2, [r3, r1]
    PM->APBCMASK.bit.AUXMCU_APB_SERCOM_BIT = 1;                                                             // Enable SERCOM APB Clock Enable
    2954:	4a11      	ldr	r2, [pc, #68]	; (299c <platform_io_init_aux_comms+0x90>)
    2956:	6a13      	ldr	r3, [r2, #32]
    2958:	3918      	subs	r1, #24
    295a:	430b      	orrs	r3, r1
    295c:	6213      	str	r3, [r2, #32]
    clocks_map_gclk_to_peripheral_clock(GCLK_ID_48M, AUXMCU_GCLK_SERCOM_ID);                                // Map 48MHz to SERCOM unit    
    295e:	3909      	subs	r1, #9
    2960:	2000      	movs	r0, #0
    2962:	4b0f      	ldr	r3, [pc, #60]	; (29a0 <platform_io_init_aux_comms+0x94>)
    2964:	4798      	blx	r3
    SERCOM_USART_CTRLA_Type temp_ctrla_reg;
    temp_ctrla_reg.reg = 0;
    temp_ctrla_reg.bit.SAMPR = 2;
    temp_ctrla_reg.bit.RXPO = AUXMCU_RX_TXPO;
    temp_ctrla_reg.bit.TXPO = AUXMCU_TX_PAD;
    temp_ctrla_reg.bit.MODE = SERCOM_USART_CTRLA_MODE_USART_INT_CLK_Val;
    2966:	480f      	ldr	r0, [pc, #60]	; (29a4 <platform_io_init_aux_comms+0x98>)
    AUXMCU_SERCOM->USART.CTRLA = temp_ctrla_reg;
    2968:	4b0f      	ldr	r3, [pc, #60]	; (29a8 <platform_io_init_aux_comms+0x9c>)
    296a:	6018      	str	r0, [r3, #0]
    /* TX & RX en, 8bits */
    SERCOM_USART_CTRLB_Type temp_ctrlb_reg;
    temp_ctrlb_reg.reg = 0;
    temp_ctrlb_reg.bit.RXEN = 1;
    temp_ctrlb_reg.bit.TXEN = 1;
    while ((AUXMCU_SERCOM->USART.SYNCBUSY.reg & SERCOM_USART_SYNCBUSY_CTRLB) != 0);
    296c:	0019      	movs	r1, r3
    296e:	2204      	movs	r2, #4
    2970:	69cb      	ldr	r3, [r1, #28]
    2972:	421a      	tst	r2, r3
    2974:	d1fc      	bne.n	2970 <platform_io_init_aux_comms+0x64>
    AUXMCU_SERCOM->USART.CTRLB = temp_ctrlb_reg;
    2976:	4b0c      	ldr	r3, [pc, #48]	; (29a8 <platform_io_init_aux_comms+0x9c>)
    2978:	22c0      	movs	r2, #192	; 0xc0
    297a:	0292      	lsls	r2, r2, #10
    297c:	605a      	str	r2, [r3, #4]
    /* Set max baud rate */
    AUXMCU_SERCOM->USART.BAUD.reg = 0;
    297e:	2200      	movs	r2, #0
    2980:	819a      	strh	r2, [r3, #12]
    /* Enable sercom */
    temp_ctrla_reg.reg |= SERCOM_USART_CTRLA_ENABLE;
    2982:	2302      	movs	r3, #2
    2984:	4318      	orrs	r0, r3
    while ((AUXMCU_SERCOM->USART.SYNCBUSY.reg & SERCOM_USART_SYNCBUSY_ENABLE) != 0);
    2986:	4908      	ldr	r1, [pc, #32]	; (29a8 <platform_io_init_aux_comms+0x9c>)
    2988:	3202      	adds	r2, #2
    298a:	69cb      	ldr	r3, [r1, #28]
    298c:	421a      	tst	r2, r3
    298e:	d1fc      	bne.n	298a <platform_io_init_aux_comms+0x7e>
    AUXMCU_SERCOM->USART.CTRLA = temp_ctrla_reg;
    2990:	4b05      	ldr	r3, [pc, #20]	; (29a8 <platform_io_init_aux_comms+0x9c>)
    2992:	6018      	str	r0, [r3, #0]
}
    2994:	bd10      	pop	{r4, pc}
    2996:	46c0      	nop			; (mov r8, r8)
    2998:	41004400 	.word	0x41004400
    299c:	40000400 	.word	0x40000400
    29a0:	00002115 	.word	0x00002115
    29a4:	00104004 	.word	0x00104004
    29a8:	42001400 	.word	0x42001400

000029ac <platform_io_disable_main_comms>:

/*! \fn     platform_io_disable_main_comms(void)
*   \brief  Disable ports dedicated to aux comms
*/
void platform_io_disable_main_comms(void)
{
    29ac:	b510      	push	{r4, lr}
    /* Reduces standby current by 40uA */
    PORT->Group[AUX_MCU_TX_GROUP].PINCFG[AUX_MCU_TX_PINID].bit.PMUXEN = 0;                                  // AUX MCU TX, MAIN MCU RX: Disable peripheral multiplexer
    29ae:	4b09      	ldr	r3, [pc, #36]	; (29d4 <platform_io_disable_main_comms+0x28>)
    29b0:	2250      	movs	r2, #80	; 0x50
    29b2:	5c99      	ldrb	r1, [r3, r2]
    29b4:	2401      	movs	r4, #1
    29b6:	43a1      	bics	r1, r4
    29b8:	5499      	strb	r1, [r3, r2]
    PORT->Group[AUX_MCU_RX_GROUP].PINCFG[AUX_MCU_RX_PINID].bit.PMUXEN = 0;                                  // AUX MCU RX, MAIN MCU TX: Disable peripheral multiplexer
    29ba:	2051      	movs	r0, #81	; 0x51
    29bc:	5c19      	ldrb	r1, [r3, r0]
    29be:	43a1      	bics	r1, r4
    29c0:	5419      	strb	r1, [r3, r0]
    PORT->Group[AUX_MCU_TX_GROUP].OUTSET.reg = AUX_MCU_TX_MASK;                                             // AUX MCU TX, MAIN MCU RX: Pull up
    29c2:	2180      	movs	r1, #128	; 0x80
    29c4:	0249      	lsls	r1, r1, #9
    29c6:	6199      	str	r1, [r3, #24]
    PORT->Group[AUX_MCU_TX_GROUP].PINCFG[AUX_MCU_TX_PINID].bit.PULLEN = 1;                                  // AUX MCU TX, MAIN MCU RX: Pull up
    29c8:	5c99      	ldrb	r1, [r3, r2]
    29ca:	2004      	movs	r0, #4
    29cc:	4301      	orrs	r1, r0
    29ce:	5499      	strb	r1, [r3, r2]
}
    29d0:	bd10      	pop	{r4, pc}
    29d2:	46c0      	nop			; (mov r8, r8)
    29d4:	41004400 	.word	0x41004400

000029d8 <platform_io_enable_main_comms>:

/*! \fn     platform_io_enable_main_comms(void)
*   \brief  Enable ports dedicated to aux comms
*/
void platform_io_enable_main_comms(void)
{
    29d8:	b510      	push	{r4, lr}
    PORT->Group[AUX_MCU_TX_GROUP].PINCFG[AUX_MCU_TX_PINID].bit.PMUXEN = 1;                                  // AUX MCU TX, MAIN MCU RX: Enable peripheral multiplexer
    29da:	4b07      	ldr	r3, [pc, #28]	; (29f8 <platform_io_enable_main_comms+0x20>)
    29dc:	2250      	movs	r2, #80	; 0x50
    29de:	5c98      	ldrb	r0, [r3, r2]
    29e0:	2401      	movs	r4, #1
    29e2:	4320      	orrs	r0, r4
    29e4:	5498      	strb	r0, [r3, r2]
    PORT->Group[AUX_MCU_RX_GROUP].PINCFG[AUX_MCU_RX_PINID].bit.PMUXEN = 1;                                  // AUX MCU RX, MAIN MCU TX: Enable peripheral multiplexer
    29e6:	2051      	movs	r0, #81	; 0x51
    29e8:	5c19      	ldrb	r1, [r3, r0]
    29ea:	4321      	orrs	r1, r4
    29ec:	5419      	strb	r1, [r3, r0]
    PORT->Group[AUX_MCU_TX_GROUP].PINCFG[AUX_MCU_TX_PINID].bit.PULLEN = 0;                                  // AUX MCU RX, MAIN MCU TX: Pull up disable
    29ee:	5c99      	ldrb	r1, [r3, r2]
    29f0:	384d      	subs	r0, #77	; 0x4d
    29f2:	4381      	bics	r1, r0
    29f4:	5499      	strb	r1, [r3, r2]
}
    29f6:	bd10      	pop	{r4, pc}
    29f8:	41004400 	.word	0x41004400

000029fc <platform_io_init_usb_ports>:

/*! \fn     platform_io_init_usb_ports(void)
*   \brief  Initialize the platform USB ports
*/
void platform_io_init_usb_ports(void)
{
    29fc:	b510      	push	{r4, lr}
    PORT->Group[USB_DM_GROUP].PINCFG[USB_DM_PINID].bit.PMUXEN = 1;
    29fe:	4b0c      	ldr	r3, [pc, #48]	; (2a30 <platform_io_init_usb_ports+0x34>)
    2a00:	2258      	movs	r2, #88	; 0x58
    2a02:	5c99      	ldrb	r1, [r3, r2]
    2a04:	2401      	movs	r4, #1
    2a06:	4321      	orrs	r1, r4
    2a08:	5499      	strb	r1, [r3, r2]
    PORT->Group[USB_DM_GROUP].PMUX[USB_DM_PINID/2].bit.USB_DM_PMUXREGID = USB_DM_PMUX_ID;
    2a0a:	213c      	movs	r1, #60	; 0x3c
    2a0c:	5c5a      	ldrb	r2, [r3, r1]
    2a0e:	200f      	movs	r0, #15
    2a10:	4382      	bics	r2, r0
    2a12:	2006      	movs	r0, #6
    2a14:	4302      	orrs	r2, r0
    2a16:	545a      	strb	r2, [r3, r1]
    PORT->Group[USB_DP_GROUP].PINCFG[USB_DP_PINID].bit.PMUXEN = 1;
    2a18:	2059      	movs	r0, #89	; 0x59
    2a1a:	5c1a      	ldrb	r2, [r3, r0]
    2a1c:	4322      	orrs	r2, r4
    2a1e:	541a      	strb	r2, [r3, r0]
    PORT->Group[USB_DP_GROUP].PMUX[USB_DP_PINID/2].bit.USB_DP_PMUXREGID = USB_DP_PMUX_ID;    
    2a20:	5c58      	ldrb	r0, [r3, r1]
    2a22:	220f      	movs	r2, #15
    2a24:	4002      	ands	r2, r0
    2a26:	2060      	movs	r0, #96	; 0x60
    2a28:	4302      	orrs	r2, r0
    2a2a:	545a      	strb	r2, [r3, r1]
}
    2a2c:	bd10      	pop	{r4, pc}
    2a2e:	46c0      	nop			; (mov r8, r8)
    2a30:	41004400 	.word	0x41004400

00002a34 <platform_io_init_ports>:

/*! \fn     platform_io_init_ports(void)
*   \brief  Initialize the platform IO ports
*/
void platform_io_init_ports(void)
{    
    2a34:	b510      	push	{r4, lr}
    /* Aux comms */
    platform_io_init_aux_comms();
    2a36:	4b02      	ldr	r3, [pc, #8]	; (2a40 <platform_io_init_ports+0xc>)
    2a38:	4798      	blx	r3
    
    /* USB comms */
    platform_io_init_usb_ports();
    2a3a:	4b02      	ldr	r3, [pc, #8]	; (2a44 <platform_io_init_ports+0x10>)
    2a3c:	4798      	blx	r3
}    
    2a3e:	bd10      	pop	{r4, pc}
    2a40:	0000290d 	.word	0x0000290d
    2a44:	000029fd 	.word	0x000029fd

00002a48 <platform_io_prepare_ports_for_sleep>:

/*! \fn     platform_io_prepare_ports_for_sleep(void)
*   \brief  Prepare the platform ports for sleep
*/
void platform_io_prepare_ports_for_sleep(void)
{        
    2a48:	b510      	push	{r4, lr}
    /* Disable main comms ports */    
    platform_io_disable_main_comms();
    2a4a:	4b01      	ldr	r3, [pc, #4]	; (2a50 <platform_io_prepare_ports_for_sleep+0x8>)
    2a4c:	4798      	blx	r3
}
    2a4e:	bd10      	pop	{r4, pc}
    2a50:	000029ad 	.word	0x000029ad

00002a54 <platform_io_prepare_ports_for_sleep_exit>:

/*! \fn     platform_io_prepare_ports_for_sleep_exit(void)
*   \brief  Prepare the platform ports for sleep exit
*/
void platform_io_prepare_ports_for_sleep_exit(void)
{    
    2a54:	b510      	push	{r4, lr}
    /* Enable main comms ports */
    platform_io_enable_main_comms();
    2a56:	4b01      	ldr	r3, [pc, #4]	; (2a5c <platform_io_prepare_ports_for_sleep_exit+0x8>)
    2a58:	4798      	blx	r3
    2a5a:	bd10      	pop	{r4, pc}
    2a5c:	000029d9 	.word	0x000029d9

00002a60 <fuses_check_program>:
*   \brief  Check for correct fuse settings (and flash)
*   \param  flash_fuses Set to TRUE to allow fuse programming
*   \return If the check / flash was correctly performed
*/
RET_TYPE fuses_check_program(BOOL flash_fuses)
{
    2a60:	b530      	push	{r4, r5, lr}
    /* Get current words */
    uint32_t userWord0 = *((uint32_t *)NVMCTRL_AUX0_ADDRESS);
    2a62:	4b2a      	ldr	r3, [pc, #168]	; (2b0c <fuses_check_program+0xac>)
    2a64:	681b      	ldr	r3, [r3, #0]
    uint32_t userWord1 = *(((uint32_t *)NVMCTRL_AUX0_ADDRESS) + 1);
    2a66:	4a2a      	ldr	r2, [pc, #168]	; (2b10 <fuses_check_program+0xb0>)
    2a68:	6811      	ldr	r1, [r2, #0]
    
    /* Check current words and security bit */
    #ifdef NO_SECURITY_BIT_CHECK
    if ((userWord0 == USER_WORD_0) && (userWord1 == USER_WORD_1))
    2a6a:	4a2a      	ldr	r2, [pc, #168]	; (2b14 <fuses_check_program+0xb4>)
    2a6c:	4293      	cmp	r3, r2
    2a6e:	d008      	beq.n	2a82 <fuses_check_program+0x22>
        /* Conf words & security bit ok */
        return RETURN_OK;
    }
    
    /* Incorrect words, check if we are allowed to flash them */
    if (flash_fuses == FALSE)
    2a70:	2800      	cmp	r0, #0
    2a72:	d048      	beq.n	2b06 <fuses_check_program+0xa6>
    {
        return RETURN_NOK;
    }
    
    /* We are allowed to program, check for security bit */
    if (NVMCTRL->STATUS.reg & NVMCTRL_STATUS_SB)
    2a74:	4a28      	ldr	r2, [pc, #160]	; (2b18 <fuses_check_program+0xb8>)
    2a76:	8b12      	ldrh	r2, [r2, #24]
    {
        return RETURN_NOK;
    2a78:	2001      	movs	r0, #1
    2a7a:	4240      	negs	r0, r0
    if (NVMCTRL->STATUS.reg & NVMCTRL_STATUS_SB)
    2a7c:	05d2      	lsls	r2, r2, #23
    2a7e:	d505      	bpl.n	2a8c <fuses_check_program+0x2c>
    NVIC_SystemReset();
    while(1);
    
    /* To avoid warnings */
    return RETURN_NOK;
    2a80:	bd30      	pop	{r4, r5, pc}
    if ((userWord0 == USER_WORD_0) && (userWord1 == USER_WORD_1))
    2a82:	4a26      	ldr	r2, [pc, #152]	; (2b1c <fuses_check_program+0xbc>)
    2a84:	4291      	cmp	r1, r2
    2a86:	d1f3      	bne.n	2a70 <fuses_check_program+0x10>
        return RETURN_OK;
    2a88:	2000      	movs	r0, #0
    2a8a:	e7f9      	b.n	2a80 <fuses_check_program+0x20>
    uint32_t temp = NVMCTRL->CTRLB.reg;
    2a8c:	4a22      	ldr	r2, [pc, #136]	; (2b18 <fuses_check_program+0xb8>)
    2a8e:	6854      	ldr	r4, [r2, #4]
    NVMCTRL->CTRLB.bit.MANW = 0;
    2a90:	6850      	ldr	r0, [r2, #4]
    2a92:	2580      	movs	r5, #128	; 0x80
    2a94:	43a8      	bics	r0, r5
    2a96:	6050      	str	r0, [r2, #4]
    NVMCTRL->CTRLB.bit.CACHEDIS = 1;
    2a98:	6855      	ldr	r5, [r2, #4]
    2a9a:	2080      	movs	r0, #128	; 0x80
    2a9c:	02c0      	lsls	r0, r0, #11
    2a9e:	4328      	orrs	r0, r5
    2aa0:	6050      	str	r0, [r2, #4]
    NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
    2aa2:	8b10      	ldrh	r0, [r2, #24]
    2aa4:	2520      	movs	r5, #32
    2aa6:	35ff      	adds	r5, #255	; 0xff
    2aa8:	4328      	orrs	r0, r5
    2aaa:	8310      	strh	r0, [r2, #24]
    NVMCTRL->ADDR.reg = NVMCTRL_AUX0_ADDRESS / 2;
    2aac:	481c      	ldr	r0, [pc, #112]	; (2b20 <fuses_check_program+0xc0>)
    2aae:	61d0      	str	r0, [r2, #28]
    NVMCTRL->CTRLA.reg = NVM_COMMAND_ERASE_AUX_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
    2ab0:	481c      	ldr	r0, [pc, #112]	; (2b24 <fuses_check_program+0xc4>)
    2ab2:	8010      	strh	r0, [r2, #0]
    while (!(NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY));
    2ab4:	0010      	movs	r0, r2
    2ab6:	2201      	movs	r2, #1
    2ab8:	7d05      	ldrb	r5, [r0, #20]
    2aba:	4215      	tst	r5, r2
    2abc:	d0fc      	beq.n	2ab8 <fuses_check_program+0x58>
    NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
    2abe:	4a16      	ldr	r2, [pc, #88]	; (2b18 <fuses_check_program+0xb8>)
    2ac0:	8b10      	ldrh	r0, [r2, #24]
    2ac2:	2520      	movs	r5, #32
    2ac4:	35ff      	adds	r5, #255	; 0xff
    2ac6:	4328      	orrs	r0, r5
    2ac8:	8310      	strh	r0, [r2, #24]
    NVMCTRL->ADDR.reg = NVMCTRL_AUX0_ADDRESS / 2;
    2aca:	4815      	ldr	r0, [pc, #84]	; (2b20 <fuses_check_program+0xc0>)
    2acc:	61d0      	str	r0, [r2, #28]
    userWord0 &= USER_MASK_0;
    2ace:	4816      	ldr	r0, [pc, #88]	; (2b28 <fuses_check_program+0xc8>)
    2ad0:	4003      	ands	r3, r0
    userWord1 &= USER_MASK_1;
    2ad2:	0a49      	lsrs	r1, r1, #9
    2ad4:	0249      	lsls	r1, r1, #9
    userWord0 |= USER_WORD_0;
    2ad6:	480f      	ldr	r0, [pc, #60]	; (2b14 <fuses_check_program+0xb4>)
    2ad8:	4303      	orrs	r3, r0
    *((uint32_t *)NVMCTRL_AUX0_ADDRESS) = userWord0;
    2ada:	480c      	ldr	r0, [pc, #48]	; (2b0c <fuses_check_program+0xac>)
    2adc:	6003      	str	r3, [r0, #0]
    userWord1 |= USER_WORD_1;
    2ade:	4b0f      	ldr	r3, [pc, #60]	; (2b1c <fuses_check_program+0xbc>)
    2ae0:	4319      	orrs	r1, r3
    *(((uint32_t *)NVMCTRL_AUX0_ADDRESS) + 1) = userWord1;
    2ae2:	4b0b      	ldr	r3, [pc, #44]	; (2b10 <fuses_check_program+0xb0>)
    2ae4:	6019      	str	r1, [r3, #0]
    NVMCTRL->CTRLA.reg = NVM_COMMAND_WRITE_AUX_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
    2ae6:	4b11      	ldr	r3, [pc, #68]	; (2b2c <fuses_check_program+0xcc>)
    2ae8:	8013      	strh	r3, [r2, #0]
    while (!(NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY));
    2aea:	2301      	movs	r3, #1
    2aec:	7d11      	ldrb	r1, [r2, #20]
    2aee:	4219      	tst	r1, r3
    2af0:	d0fc      	beq.n	2aec <fuses_check_program+0x8c>
    NVMCTRL->CTRLB.reg = temp;
    2af2:	4b09      	ldr	r3, [pc, #36]	; (2b18 <fuses_check_program+0xb8>)
    2af4:	605c      	str	r4, [r3, #4]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
    2af6:	f3bf 8f4f 	dsb	sy
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
    2afa:	4a0d      	ldr	r2, [pc, #52]	; (2b30 <fuses_check_program+0xd0>)
    2afc:	4b0d      	ldr	r3, [pc, #52]	; (2b34 <fuses_check_program+0xd4>)
    2afe:	60da      	str	r2, [r3, #12]
    2b00:	f3bf 8f4f 	dsb	sy
    2b04:	e7fe      	b.n	2b04 <fuses_check_program+0xa4>
        return RETURN_NOK;
    2b06:	2001      	movs	r0, #1
    2b08:	4240      	negs	r0, r0
    2b0a:	e7b9      	b.n	2a80 <fuses_check_program+0x20>
    2b0c:	00804000 	.word	0x00804000
    2b10:	00804004 	.word	0x00804004
    2b14:	d8e0a7ef 	.word	0xd8e0a7ef
    2b18:	41004000 	.word	0x41004000
    2b1c:	fffffc5a 	.word	0xfffffc5a
    2b20:	00402000 	.word	0x00402000
    2b24:	ffffa505 	.word	0xffffa505
    2b28:	01fe0088 	.word	0x01fe0088
    2b2c:	ffffa506 	.word	0xffffa506
    2b30:	05fa0004 	.word	0x05fa0004
    2b34:	e000ed00 	.word	0xe000ed00

00002b38 <timer_initialize_timebase>:
/*! \fn     timer_initialize_timebase(void)
*   \brief  Initialize the platform time base
*   \note   Will use GCLK3 for a 1.024KHz and uses the RTC module in calendar mode
*/
void timer_initialize_timebase(void)
{        
    2b38:	b510      	push	{r4, lr}
    /* Assign internal 32kHz to GCLK3, divide it by 32 */
    GCLK_GENDIV_Type gendiv_reg;                                        // Gendiv struct
    gendiv_reg.bit.ID = GCLK_CLKCTRL_GEN_GCLK3_Val;                     // Select gclk3
    gendiv_reg.bit.DIV = 32;                                            // Divide by 32
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);             // Wait for sync
    2b3a:	4a35      	ldr	r2, [pc, #212]	; (2c10 <timer_initialize_timebase+0xd8>)
    2b3c:	7853      	ldrb	r3, [r2, #1]
    2b3e:	b25b      	sxtb	r3, r3
    2b40:	2b00      	cmp	r3, #0
    2b42:	dbfb      	blt.n	2b3c <timer_initialize_timebase+0x4>
    GCLK->GENDIV = gendiv_reg;                                          // Write register
    2b44:	4b32      	ldr	r3, [pc, #200]	; (2c10 <timer_initialize_timebase+0xd8>)
    2b46:	4a33      	ldr	r2, [pc, #204]	; (2c14 <timer_initialize_timebase+0xdc>)
    2b48:	609a      	str	r2, [r3, #8]
    genctrl.bit.SRC = GCLK_GENCTRL_SRC_OSCULP32K_Val;                   // Assign ultra low power 32kHz
    genctrl.bit.GENEN = 1;                                              // Enable generator
    genctrl.bit.DIVSEL = 0;                                             // Divide clock by gendiv.div
    genctrl.bit.OE = 1;                                                 // Do not output clock
    genctrl.bit.RUNSTDBY = 1;                                           // Run in standby
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);             // Wait for sync
    2b4a:	001a      	movs	r2, r3
    2b4c:	7853      	ldrb	r3, [r2, #1]
    2b4e:	b25b      	sxtb	r3, r3
    2b50:	2b00      	cmp	r3, #0
    2b52:	dbfb      	blt.n	2b4c <timer_initialize_timebase+0x14>
    GCLK->GENCTRL = genctrl;                                            // Write register
    2b54:	4b2e      	ldr	r3, [pc, #184]	; (2c10 <timer_initialize_timebase+0xd8>)
    2b56:	4a30      	ldr	r2, [pc, #192]	; (2c18 <timer_initialize_timebase+0xe0>)
    2b58:	605a      	str	r2, [r3, #4]
    
    /* Set GCLK Multiplexer 4 (for GCLK_RTC) to 1kHz GCLK3 */
    GCLK_CLKCTRL_Type clkctrl;                                          // Clkctrl struct
    clkctrl.reg = GCLK_CLKCTRL_ID_RTC;                                  // Disable RTC clock generator
    clkctrl.bit.GEN = GCLK_CLKCTRL_GEN_GCLK2_Val;                       // Default value
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);             // Wait for sync
    2b5a:	001a      	movs	r2, r3
    2b5c:	7853      	ldrb	r3, [r2, #1]
    2b5e:	b25b      	sxtb	r3, r3
    2b60:	2b00      	cmp	r3, #0
    2b62:	dbfb      	blt.n	2b5c <timer_initialize_timebase+0x24>
    GCLK->CLKCTRL = clkctrl;                                            // Write register    
    2b64:	4b2a      	ldr	r3, [pc, #168]	; (2c10 <timer_initialize_timebase+0xd8>)
    2b66:	2281      	movs	r2, #129	; 0x81
    2b68:	0092      	lsls	r2, r2, #2
    2b6a:	805a      	strh	r2, [r3, #2]
    while ((GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) != 0);              // Wait for clock disable
    2b6c:	0019      	movs	r1, r3
    2b6e:	2280      	movs	r2, #128	; 0x80
    2b70:	01d2      	lsls	r2, r2, #7
    2b72:	884b      	ldrh	r3, [r1, #2]
    2b74:	4213      	tst	r3, r2
    2b76:	d1fc      	bne.n	2b72 <timer_initialize_timebase+0x3a>
    clkctrl.reg = 0;                                                    // Reset temp var
    clkctrl.bit.ID = GCLK_CLKCTRL_ID_RTC_Val;                           // Select RTC input
    clkctrl.bit.GEN = GCLK_CLKCTRL_GEN_GCLK3_Val;                       // Select gclk3
    clkctrl.bit.CLKEN = 1;                                              // Enable generator
    while ((GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) != 0);             // Wait for sync
    2b78:	4a25      	ldr	r2, [pc, #148]	; (2c10 <timer_initialize_timebase+0xd8>)
    2b7a:	7853      	ldrb	r3, [r2, #1]
    2b7c:	b25b      	sxtb	r3, r3
    2b7e:	2b00      	cmp	r3, #0
    2b80:	dbfb      	blt.n	2b7a <timer_initialize_timebase+0x42>
    GCLK->CLKCTRL = clkctrl;                                            // Write register
    2b82:	4b23      	ldr	r3, [pc, #140]	; (2c10 <timer_initialize_timebase+0xd8>)
    2b84:	4a25      	ldr	r2, [pc, #148]	; (2c1c <timer_initialize_timebase+0xe4>)
    2b86:	805a      	strh	r2, [r3, #2]
    
    /* Setup RTC module in calendar mode */
    while((RTC->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) != 0);          // Wait for sync
    2b88:	4a25      	ldr	r2, [pc, #148]	; (2c20 <timer_initialize_timebase+0xe8>)
    2b8a:	7a93      	ldrb	r3, [r2, #10]
    2b8c:	b25b      	sxtb	r3, r3
    2b8e:	2b00      	cmp	r3, #0
    2b90:	dbfb      	blt.n	2b8a <timer_initialize_timebase+0x52>
    RTC->MODE2.CTRL.reg = 0;                                            // Disable RTC
    2b92:	2200      	movs	r2, #0
    2b94:	4b22      	ldr	r3, [pc, #136]	; (2c20 <timer_initialize_timebase+0xe8>)
    2b96:	801a      	strh	r2, [r3, #0]
    while((RTC->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) != 0);          // Wait for sync
    2b98:	001a      	movs	r2, r3
    2b9a:	7a93      	ldrb	r3, [r2, #10]
    2b9c:	b25b      	sxtb	r3, r3
    2b9e:	2b00      	cmp	r3, #0
    2ba0:	dbfb      	blt.n	2b9a <timer_initialize_timebase+0x62>
    RTC->MODE2.CTRL.reg = RTC_MODE2_CTRL_SWRST;                         // Reset RTC
    2ba2:	2201      	movs	r2, #1
    2ba4:	4b1e      	ldr	r3, [pc, #120]	; (2c20 <timer_initialize_timebase+0xe8>)
    2ba6:	801a      	strh	r2, [r3, #0]
    while((RTC->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) != 0);          // Wait for sync
    2ba8:	001a      	movs	r2, r3
    2baa:	7a93      	ldrb	r3, [r2, #10]
    2bac:	b25b      	sxtb	r3, r3
    2bae:	2b00      	cmp	r3, #0
    2bb0:	dbfb      	blt.n	2baa <timer_initialize_timebase+0x72>
    while((RTC->MODE2.CTRL.reg & RTC_MODE2_CTRL_SWRST) != 0);           // Wait for end of reset
    2bb2:	491b      	ldr	r1, [pc, #108]	; (2c20 <timer_initialize_timebase+0xe8>)
    2bb4:	2201      	movs	r2, #1
    2bb6:	880b      	ldrh	r3, [r1, #0]
    2bb8:	4213      	tst	r3, r2
    2bba:	d1fc      	bne.n	2bb6 <timer_initialize_timebase+0x7e>
    RTC_MODE2_CTRL_Type rtc_ctrl_reg;                                   // rtc ctrl struct
    rtc_ctrl_reg.reg = RTC_MODE1_CTRL_ENABLE;                           // Enable module
    rtc_ctrl_reg.bit.CLKREP = 0;                                        // 24 hour mode
    rtc_ctrl_reg.bit.MODE = RTC_MODE2_CTRL_MODE_CLOCK_Val;              // Calendar mode
    rtc_ctrl_reg.bit.PRESCALER = RTC_MODE2_CTRL_PRESCALER_DIV1024_Val;  // Divide 1.024kHz signal by 1024
    while((RTC->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) != 0);          // Wait for sync
    2bbc:	4a18      	ldr	r2, [pc, #96]	; (2c20 <timer_initialize_timebase+0xe8>)
    2bbe:	7a93      	ldrb	r3, [r2, #10]
    2bc0:	b25b      	sxtb	r3, r3
    2bc2:	2b00      	cmp	r3, #0
    2bc4:	dbfb      	blt.n	2bbe <timer_initialize_timebase+0x86>
    RTC->MODE2.CTRL = rtc_ctrl_reg;                                     // Write register
    2bc6:	4b16      	ldr	r3, [pc, #88]	; (2c20 <timer_initialize_timebase+0xe8>)
    2bc8:	4a16      	ldr	r2, [pc, #88]	; (2c24 <timer_initialize_timebase+0xec>)
    2bca:	801a      	strh	r2, [r3, #0]
    //RTC->MODE2.DBGCTRL.bit.DBGRUN = 1;                                  // Allow normal operation during debug mode
    
    /* Set GCLK Multiplexer 0x1A (for GCLK_TCC0) to 48MHz GCLK0 */
    clocks_map_gclk_to_peripheral_clock(GCLK_ID_48M, GCLK_CLKCTRL_ID_TCC0_TCC1_Val);
    2bcc:	211a      	movs	r1, #26
    2bce:	2000      	movs	r0, #0
    2bd0:	4b15      	ldr	r3, [pc, #84]	; (2c28 <timer_initialize_timebase+0xf0>)
    2bd2:	4798      	blx	r3
    
    /* Setup TCC0 for 1ms interrupt */
    PM->APBCMASK.bit.TCC0_ = 1;                                         // Enable APBC clock for TCC0
    2bd4:	4a15      	ldr	r2, [pc, #84]	; (2c2c <timer_initialize_timebase+0xf4>)
    2bd6:	6a11      	ldr	r1, [r2, #32]
    2bd8:	2380      	movs	r3, #128	; 0x80
    2bda:	005b      	lsls	r3, r3, #1
    2bdc:	430b      	orrs	r3, r1
    2bde:	6213      	str	r3, [r2, #32]
    while(TCC0->SYNCBUSY.reg & TCC_SYNCBUSY_PER);                       // Wait for sync
    2be0:	4913      	ldr	r1, [pc, #76]	; (2c30 <timer_initialize_timebase+0xf8>)
    2be2:	2280      	movs	r2, #128	; 0x80
    2be4:	688b      	ldr	r3, [r1, #8]
    2be6:	421a      	tst	r2, r3
    2be8:	d1fc      	bne.n	2be4 <timer_initialize_timebase+0xac>
    TCC0->PER.reg = TCC_PER_PER(48000-1);                               // Set period to be 48M/48000 = 1k
    2bea:	4a12      	ldr	r2, [pc, #72]	; (2c34 <timer_initialize_timebase+0xfc>)
    2bec:	4b10      	ldr	r3, [pc, #64]	; (2c30 <timer_initialize_timebase+0xf8>)
    2bee:	641a      	str	r2, [r3, #64]	; 0x40
    TCC_CTRLA_Type tcc_ctrl_reg;                                        // tcc ctrl reg
    tcc_ctrl_reg.reg = TCC_CTRLA_ENABLE;                                // Enable tcc0
    tcc_ctrl_reg.bit.RUNSTDBY = 0;                                      // Do not run during standby
    tcc_ctrl_reg.bit.PRESCALER = TCC_CTRLA_PRESCALER_DIV1_Val;          // No prescaling
    while(TCC0->SYNCBUSY.reg & TCC_SYNCBUSY_ENABLE);                    // Wait for sync
    2bf0:	0019      	movs	r1, r3
    2bf2:	2202      	movs	r2, #2
    2bf4:	688b      	ldr	r3, [r1, #8]
    2bf6:	421a      	tst	r2, r3
    2bf8:	d1fc      	bne.n	2bf4 <timer_initialize_timebase+0xbc>
    TCC0->CTRLA = tcc_ctrl_reg;                                         // Write register
    2bfa:	4b0d      	ldr	r3, [pc, #52]	; (2c30 <timer_initialize_timebase+0xf8>)
    2bfc:	2202      	movs	r2, #2
    2bfe:	601a      	str	r2, [r3, #0]
    TCC0->INTENSET.reg = TCC_INTENSET_OVF;                              // Enable overflow interrupt
    2c00:	3a01      	subs	r2, #1
    2c02:	629a      	str	r2, [r3, #40]	; 0x28
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    2c04:	2280      	movs	r2, #128	; 0x80
    2c06:	0212      	lsls	r2, r2, #8
    2c08:	4b0b      	ldr	r3, [pc, #44]	; (2c38 <timer_initialize_timebase+0x100>)
    2c0a:	601a      	str	r2, [r3, #0]
    NVIC_EnableIRQ(TCC0_IRQn);                                          // Enable int
}
    2c0c:	bd10      	pop	{r4, pc}
    2c0e:	46c0      	nop			; (mov r8, r8)
    2c10:	40000c00 	.word	0x40000c00
    2c14:	00002003 	.word	0x00002003
    2c18:	00290303 	.word	0x00290303
    2c1c:	00004304 	.word	0x00004304
    2c20:	40001400 	.word	0x40001400
    2c24:	00000a0a 	.word	0x00000a0a
    2c28:	00002115 	.word	0x00002115
    2c2c:	40000400 	.word	0x40000400
    2c30:	42002000 	.word	0x42002000
    2c34:	0000bb7f 	.word	0x0000bb7f
    2c38:	e000e100 	.word	0xe000e100

00002c3c <timer_ms_tick>:
*	\brief	Function called by interrupt every ms
*/
void timer_ms_tick(void)
{
    uint32_t i;
    sysTick++;
    2c3c:	4a10      	ldr	r2, [pc, #64]	; (2c80 <timer_ms_tick+0x44>)
    2c3e:	6813      	ldr	r3, [r2, #0]
    2c40:	3301      	adds	r3, #1
    2c42:	6013      	str	r3, [r2, #0]
    
    // Loop through the timers
    for (i = 0; i < TOTAL_NUMBER_OF_TIMERS; i++)
    {
        if (context_timers[i].timer_val != 0)
    2c44:	4b0f      	ldr	r3, [pc, #60]	; (2c84 <timer_ms_tick+0x48>)
    2c46:	681b      	ldr	r3, [r3, #0]
    2c48:	2b00      	cmp	r3, #0
    2c4a:	d005      	beq.n	2c58 <timer_ms_tick+0x1c>
        {
            if (context_timers[i].timer_val-- == 1)
    2c4c:	4a0d      	ldr	r2, [pc, #52]	; (2c84 <timer_ms_tick+0x48>)
    2c4e:	6813      	ldr	r3, [r2, #0]
    2c50:	1e59      	subs	r1, r3, #1
    2c52:	6011      	str	r1, [r2, #0]
    2c54:	2b01      	cmp	r3, #1
    2c56:	d00a      	beq.n	2c6e <timer_ms_tick+0x32>
        if (context_timers[i].timer_val != 0)
    2c58:	4b0a      	ldr	r3, [pc, #40]	; (2c84 <timer_ms_tick+0x48>)
    2c5a:	689b      	ldr	r3, [r3, #8]
    2c5c:	2b00      	cmp	r3, #0
    2c5e:	d005      	beq.n	2c6c <timer_ms_tick+0x30>
            if (context_timers[i].timer_val-- == 1)
    2c60:	4a08      	ldr	r2, [pc, #32]	; (2c84 <timer_ms_tick+0x48>)
    2c62:	6893      	ldr	r3, [r2, #8]
    2c64:	1e59      	subs	r1, r3, #1
    2c66:	6091      	str	r1, [r2, #8]
    2c68:	2b01      	cmp	r3, #1
    2c6a:	d004      	beq.n	2c76 <timer_ms_tick+0x3a>
            {
                context_timers[i].flag = TIMER_EXPIRED;
            }
        }
    }
}
    2c6c:	4770      	bx	lr
                context_timers[i].flag = TIMER_EXPIRED;
    2c6e:	2200      	movs	r2, #0
    2c70:	4b04      	ldr	r3, [pc, #16]	; (2c84 <timer_ms_tick+0x48>)
    2c72:	605a      	str	r2, [r3, #4]
    2c74:	e7f0      	b.n	2c58 <timer_ms_tick+0x1c>
    2c76:	2200      	movs	r2, #0
    2c78:	4b02      	ldr	r3, [pc, #8]	; (2c84 <timer_ms_tick+0x48>)
    2c7a:	60da      	str	r2, [r3, #12]
}
    2c7c:	e7f6      	b.n	2c6c <timer_ms_tick+0x30>
    2c7e:	46c0      	nop			; (mov r8, r8)
    2c80:	20001100 	.word	0x20001100
    2c84:	200010f0 	.word	0x200010f0

00002c88 <TCC0_Handler>:
{
    2c88:	b510      	push	{r4, lr}
        if (TCC0->INTFLAG.reg & TCC_INTFLAG_OVF)
    2c8a:	4b05      	ldr	r3, [pc, #20]	; (2ca0 <TCC0_Handler+0x18>)
    2c8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2c8e:	07db      	lsls	r3, r3, #31
    2c90:	d400      	bmi.n	2c94 <TCC0_Handler+0xc>
}
    2c92:	bd10      	pop	{r4, pc}
            TCC0->INTFLAG.reg = TCC_INTFLAG_OVF;
    2c94:	2201      	movs	r2, #1
    2c96:	4b02      	ldr	r3, [pc, #8]	; (2ca0 <TCC0_Handler+0x18>)
    2c98:	62da      	str	r2, [r3, #44]	; 0x2c
            timer_ms_tick();
    2c9a:	4b02      	ldr	r3, [pc, #8]	; (2ca4 <TCC0_Handler+0x1c>)
    2c9c:	4798      	blx	r3
}
    2c9e:	e7f8      	b.n	2c92 <TCC0_Handler+0xa>
    2ca0:	42002000 	.word	0x42002000
    2ca4:	00002c3d 	.word	0x00002c3d

00002ca8 <udc_init>:

/*- Implementations ---------------------------------------------------------*/

//-----------------------------------------------------------------------------
void udc_init(void)
{
    2ca8:	b570      	push	{r4, r5, r6, lr}
  PM->APBBMASK.reg |= PM_APBBMASK_USB;
    2caa:	4a30      	ldr	r2, [pc, #192]	; (2d6c <udc_init+0xc4>)
    2cac:	69d3      	ldr	r3, [r2, #28]
    2cae:	2120      	movs	r1, #32
    2cb0:	430b      	orrs	r3, r1
    2cb2:	61d3      	str	r3, [r2, #28]

  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_ID(USB_GCLK_ID) |
    2cb4:	4a2e      	ldr	r2, [pc, #184]	; (2d70 <udc_init+0xc8>)
    2cb6:	4b2f      	ldr	r3, [pc, #188]	; (2d74 <udc_init+0xcc>)
    2cb8:	805a      	strh	r2, [r3, #2]
      GCLK_CLKCTRL_GEN(0);

  USB->DEVICE.CTRLA.bit.SWRST = 1;
    2cba:	4a2f      	ldr	r2, [pc, #188]	; (2d78 <udc_init+0xd0>)
    2cbc:	7813      	ldrb	r3, [r2, #0]
    2cbe:	2101      	movs	r1, #1
    2cc0:	430b      	orrs	r3, r1
    2cc2:	7013      	strb	r3, [r2, #0]
  while (USB->DEVICE.SYNCBUSY.bit.SWRST);
    2cc4:	7893      	ldrb	r3, [r2, #2]
    2cc6:	07db      	lsls	r3, r3, #31
    2cc8:	d4fc      	bmi.n	2cc4 <udc_init+0x1c>

  USB->DEVICE.PADCAL.bit.TRANSN = ((*((uint32_t *)USB_FUSES_TRANSN_ADDR)) & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
    2cca:	4b2c      	ldr	r3, [pc, #176]	; (2d7c <udc_init+0xd4>)
    2ccc:	681b      	ldr	r3, [r3, #0]
    2cce:	0b58      	lsrs	r0, r3, #13
    2cd0:	4c29      	ldr	r4, [pc, #164]	; (2d78 <udc_init+0xd0>)
    2cd2:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    2cd4:	251f      	movs	r5, #31
    2cd6:	4028      	ands	r0, r5
    2cd8:	0180      	lsls	r0, r0, #6
    2cda:	4a29      	ldr	r2, [pc, #164]	; (2d80 <udc_init+0xd8>)
    2cdc:	4011      	ands	r1, r2
    2cde:	4301      	orrs	r1, r0
    2ce0:	8521      	strh	r1, [r4, #40]	; 0x28
  USB->DEVICE.PADCAL.bit.TRANSP = ((*((uint32_t *)USB_FUSES_TRANSP_ADDR)) & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
    2ce2:	0c99      	lsrs	r1, r3, #18
    2ce4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    2ce6:	4029      	ands	r1, r5
    2ce8:	201f      	movs	r0, #31
    2cea:	4382      	bics	r2, r0
    2cec:	430a      	orrs	r2, r1
    2cee:	8522      	strh	r2, [r4, #40]	; 0x28
  USB->DEVICE.PADCAL.bit.TRIM   = ((*((uint32_t *)USB_FUSES_TRIM_ADDR)) & USB_FUSES_TRIM_Msk) >> USB_FUSES_TRIM_Pos;
    2cf0:	019b      	lsls	r3, r3, #6
    2cf2:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    2cf4:	0f5b      	lsrs	r3, r3, #29
    2cf6:	031b      	lsls	r3, r3, #12
    2cf8:	4922      	ldr	r1, [pc, #136]	; (2d84 <udc_init+0xdc>)
    2cfa:	400a      	ands	r2, r1
    2cfc:	4313      	orrs	r3, r2
    2cfe:	8523      	strh	r3, [r4, #40]	; 0x28

  memset((uint8_t *)udc_mem, 0, sizeof(udc_mem));
    2d00:	4d21      	ldr	r5, [pc, #132]	; (2d88 <udc_init+0xe0>)
    2d02:	2280      	movs	r2, #128	; 0x80
    2d04:	0052      	lsls	r2, r2, #1
    2d06:	2100      	movs	r1, #0
    2d08:	0028      	movs	r0, r5
    2d0a:	4b20      	ldr	r3, [pc, #128]	; (2d8c <udc_init+0xe4>)
    2d0c:	4798      	blx	r3
  USB->DEVICE.DESCADD.reg = (uint32_t)udc_mem;
    2d0e:	6265      	str	r5, [r4, #36]	; 0x24

  USB->DEVICE.CTRLA.bit.MODE = USB_CTRLA_MODE_DEVICE_Val;
    2d10:	7822      	ldrb	r2, [r4, #0]
    2d12:	237f      	movs	r3, #127	; 0x7f
    2d14:	4013      	ands	r3, r2
    2d16:	7023      	strb	r3, [r4, #0]
  USB->DEVICE.CTRLA.bit.RUNSTDBY = 1;
    2d18:	7823      	ldrb	r3, [r4, #0]
    2d1a:	2204      	movs	r2, #4
    2d1c:	4313      	orrs	r3, r2
    2d1e:	7023      	strb	r3, [r4, #0]
  USB->DEVICE.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_FS_Val;
    2d20:	8923      	ldrh	r3, [r4, #8]
    2d22:	220c      	movs	r2, #12
    2d24:	4393      	bics	r3, r2
    2d26:	8123      	strh	r3, [r4, #8]
  //USB->DEVICE.CTRLB.bit.DETACH = 0;

  USB->DEVICE.INTENSET.reg = USB_DEVICE_INTENSET_EORST;
    2d28:	2308      	movs	r3, #8
    2d2a:	8323      	strh	r3, [r4, #24]
  USB->DEVICE.DeviceEndpoint[0].EPINTENSET.bit.RXSTP = 1;
    2d2c:	220a      	movs	r2, #10
    2d2e:	32ff      	adds	r2, #255	; 0xff
    2d30:	5ca3      	ldrb	r3, [r4, r2]
    2d32:	2110      	movs	r1, #16
    2d34:	430b      	orrs	r3, r1
    2d36:	54a3      	strb	r3, [r4, r2]

  USB->DEVICE.CTRLA.reg |= USB_CTRLA_ENABLE;
    2d38:	7823      	ldrb	r3, [r4, #0]
    2d3a:	3a08      	subs	r2, #8
    2d3c:	3aff      	subs	r2, #255	; 0xff
    2d3e:	4313      	orrs	r3, r2
    2d40:	7023      	strb	r3, [r4, #0]

  for (int i = 0; i < USB_EPT_NUM; i++)
    2d42:	2100      	movs	r1, #0

//-----------------------------------------------------------------------------
void udc_reset_endpoint(int ep, int dir)
{
  if (USB_IN_ENDPOINT == dir)
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    2d44:	0022      	movs	r2, r4
    2d46:	2570      	movs	r5, #112	; 0x70
  else
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    2d48:	2407      	movs	r4, #7
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    2d4a:	000b      	movs	r3, r1
    2d4c:	3308      	adds	r3, #8
    2d4e:	015b      	lsls	r3, r3, #5
    2d50:	5c98      	ldrb	r0, [r3, r2]
    2d52:	43a8      	bics	r0, r5
    2d54:	5498      	strb	r0, [r3, r2]
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    2d56:	5c98      	ldrb	r0, [r3, r2]
    2d58:	43a0      	bics	r0, r4
    2d5a:	5498      	strb	r0, [r3, r2]
  for (int i = 0; i < USB_EPT_NUM; i++)
    2d5c:	3101      	adds	r1, #1
    2d5e:	2908      	cmp	r1, #8
    2d60:	d1f3      	bne.n	2d4a <udc_init+0xa2>
    2d62:	2280      	movs	r2, #128	; 0x80
    2d64:	4b0a      	ldr	r3, [pc, #40]	; (2d90 <udc_init+0xe8>)
    2d66:	601a      	str	r2, [r3, #0]
}
    2d68:	bd70      	pop	{r4, r5, r6, pc}
    2d6a:	46c0      	nop			; (mov r8, r8)
    2d6c:	40000400 	.word	0x40000400
    2d70:	00004006 	.word	0x00004006
    2d74:	40000c00 	.word	0x40000c00
    2d78:	41005000 	.word	0x41005000
    2d7c:	00806024 	.word	0x00806024
    2d80:	fffff83f 	.word	0xfffff83f
    2d84:	ffff8fff 	.word	0xffff8fff
    2d88:	20000234 	.word	0x20000234
    2d8c:	000039ff 	.word	0x000039ff
    2d90:	e000e100 	.word	0xe000e100

00002d94 <udc_attach>:
  USB->DEVICE.CTRLB.bit.DETACH = 0;
    2d94:	4a02      	ldr	r2, [pc, #8]	; (2da0 <udc_attach+0xc>)
    2d96:	8913      	ldrh	r3, [r2, #8]
    2d98:	2101      	movs	r1, #1
    2d9a:	438b      	bics	r3, r1
    2d9c:	8113      	strh	r3, [r2, #8]
}
    2d9e:	4770      	bx	lr
    2da0:	41005000 	.word	0x41005000

00002da4 <udc_configure_endpoint>:
}

//-----------------------------------------------------------------------------
void udc_configure_endpoint(usb_endpoint_descriptor_t *desc)
{
    2da4:	b5f0      	push	{r4, r5, r6, r7, lr}
  int ep, dir, type, size;

  ep = desc->bEndpointAddress & USB_INDEX_MASK;
    2da6:	7884      	ldrb	r4, [r0, #2]
    2da8:	227f      	movs	r2, #127	; 0x7f
    2daa:	4022      	ands	r2, r4
  dir = desc->bEndpointAddress & USB_DIRECTION_MASK;
    2dac:	237f      	movs	r3, #127	; 0x7f
    2dae:	439c      	bics	r4, r3
  type = desc->bmAttributes & 0x03;
    2db0:	78c3      	ldrb	r3, [r0, #3]
    2db2:	2103      	movs	r1, #3
    2db4:	4019      	ands	r1, r3
  size = desc->wMaxPacketSize & 0x3ff;
    2db6:	7905      	ldrb	r5, [r0, #4]
    2db8:	7943      	ldrb	r3, [r0, #5]
    2dba:	021b      	lsls	r3, r3, #8
    2dbc:	432b      	orrs	r3, r5
    2dbe:	059b      	lsls	r3, r3, #22
    2dc0:	0d9b      	lsrs	r3, r3, #22
  if (USB_IN_ENDPOINT == dir)
    2dc2:	2c80      	cmp	r4, #128	; 0x80
    2dc4:	d055      	beq.n	2e72 <udc_configure_endpoint+0xce>
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    2dc6:	4e44      	ldr	r6, [pc, #272]	; (2ed8 <udc_configure_endpoint+0x134>)
    2dc8:	0010      	movs	r0, r2
    2dca:	3008      	adds	r0, #8
    2dcc:	0140      	lsls	r0, r0, #5
    2dce:	5d85      	ldrb	r5, [r0, r6]
    2dd0:	2707      	movs	r7, #7
    2dd2:	43bd      	bics	r5, r7
    2dd4:	5585      	strb	r5, [r0, r6]

  udc_reset_endpoint(ep, dir);

  if (size <= 8)
    size = USB_DEVICE_PCKSIZE_SIZE_8;
    2dd6:	2500      	movs	r5, #0
  if (size <= 8)
    2dd8:	2b08      	cmp	r3, #8
    2dda:	dd16      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 16)
    size = USB_DEVICE_PCKSIZE_SIZE_16;
    2ddc:	3501      	adds	r5, #1
  else if (size <= 16)
    2dde:	2b10      	cmp	r3, #16
    2de0:	dd13      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 32)
    size = USB_DEVICE_PCKSIZE_SIZE_32;
    2de2:	3501      	adds	r5, #1
  else if (size <= 32)
    2de4:	2b20      	cmp	r3, #32
    2de6:	dd10      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 64)
    size = USB_DEVICE_PCKSIZE_SIZE_64;
    2de8:	3501      	adds	r5, #1
  else if (size <= 64)
    2dea:	2b40      	cmp	r3, #64	; 0x40
    2dec:	dd0d      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 128)
    size = USB_DEVICE_PCKSIZE_SIZE_128;
    2dee:	3501      	adds	r5, #1
  else if (size <= 128)
    2df0:	2b80      	cmp	r3, #128	; 0x80
    2df2:	dd0a      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 256)
    2df4:	2080      	movs	r0, #128	; 0x80
    2df6:	0040      	lsls	r0, r0, #1
    size = USB_DEVICE_PCKSIZE_SIZE_256;
    2df8:	3501      	adds	r5, #1
  else if (size <= 256)
    2dfa:	4283      	cmp	r3, r0
    2dfc:	dd05      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 512)
    2dfe:	3001      	adds	r0, #1
    2e00:	30ff      	adds	r0, #255	; 0xff
    size = USB_DEVICE_PCKSIZE_SIZE_512;
    2e02:	3501      	adds	r5, #1
  else if (size <= 512)
    2e04:	4283      	cmp	r3, r0
    2e06:	dd00      	ble.n	2e0a <udc_configure_endpoint+0x66>
  else if (size <= 1023)
    size = USB_DEVICE_PCKSIZE_SIZE_1023;
    2e08:	3501      	adds	r5, #1
  else
    while (1);

  if (USB_CONTROL_ENDPOINT == type)
    type = USB_DEVICE_EPCFG_EPTYPE_CONTROL;
    2e0a:	2001      	movs	r0, #1
  if (USB_CONTROL_ENDPOINT == type)
    2e0c:	2900      	cmp	r1, #0
    2e0e:	d006      	beq.n	2e1e <udc_configure_endpoint+0x7a>
  else if (USB_ISOCHRONOUS_ENDPOINT == type)
    2e10:	2901      	cmp	r1, #1
    2e12:	d037      	beq.n	2e84 <udc_configure_endpoint+0xe0>
    type = USB_DEVICE_EPCFG_EPTYPE_ISOCHRONOUS;
  else if (USB_BULK_ENDPOINT == type)
    type = USB_DEVICE_EPCFG_EPTYPE_BULK;
  else
    type = USB_DEVICE_EPCFG_EPTYPE_INTERRUPT;
    2e14:	3902      	subs	r1, #2
    2e16:	0008      	movs	r0, r1
    2e18:	1e41      	subs	r1, r0, #1
    2e1a:	4188      	sbcs	r0, r1
    2e1c:	3003      	adds	r0, #3

  if (USB_IN_ENDPOINT == dir)
    2e1e:	2c80      	cmp	r4, #128	; 0x80
    2e20:	d032      	beq.n	2e88 <udc_configure_endpoint+0xe4>
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1;
    udc_mem[ep].in.PCKSIZE.bit.SIZE = size;
  }
  else
  {
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type;
    2e22:	2607      	movs	r6, #7
    2e24:	4f2c      	ldr	r7, [pc, #176]	; (2ed8 <udc_configure_endpoint+0x134>)
    2e26:	0013      	movs	r3, r2
    2e28:	3308      	adds	r3, #8
    2e2a:	015b      	lsls	r3, r3, #5
    2e2c:	5ddc      	ldrb	r4, [r3, r7]
    2e2e:	0001      	movs	r1, r0
    2e30:	4031      	ands	r1, r6
    2e32:	2007      	movs	r0, #7
    2e34:	4384      	bics	r4, r0
    2e36:	0020      	movs	r0, r4
    2e38:	4308      	orrs	r0, r1
    2e3a:	55d8      	strb	r0, [r3, r7]
    USB->DEVICE.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1;
    2e3c:	0154      	lsls	r4, r2, #5
    2e3e:	4a27      	ldr	r2, [pc, #156]	; (2edc <udc_configure_endpoint+0x138>)
    2e40:	18a1      	adds	r1, r4, r2
    2e42:	7848      	ldrb	r0, [r1, #1]
    2e44:	2201      	movs	r2, #1
    2e46:	4310      	orrs	r0, r2
    2e48:	7048      	strb	r0, [r1, #1]
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.DTGLOUT = 1;
    2e4a:	46bc      	mov	ip, r7
    2e4c:	4463      	add	r3, ip
    2e4e:	7919      	ldrb	r1, [r3, #4]
    2e50:	4311      	orrs	r1, r2
    2e52:	7119      	strb	r1, [r3, #4]
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1;
    2e54:	7959      	ldrb	r1, [r3, #5]
    2e56:	2240      	movs	r2, #64	; 0x40
    2e58:	4311      	orrs	r1, r2
    2e5a:	7159      	strb	r1, [r3, #5]
    udc_mem[ep].out.PCKSIZE.bit.SIZE = size;
    2e5c:	0033      	movs	r3, r6
    2e5e:	402b      	ands	r3, r5
    2e60:	4a1f      	ldr	r2, [pc, #124]	; (2ee0 <udc_configure_endpoint+0x13c>)
    2e62:	1912      	adds	r2, r2, r4
    2e64:	6851      	ldr	r1, [r2, #4]
    2e66:	071b      	lsls	r3, r3, #28
    2e68:	481e      	ldr	r0, [pc, #120]	; (2ee4 <udc_configure_endpoint+0x140>)
    2e6a:	4001      	ands	r1, r0
    2e6c:	430b      	orrs	r3, r1
    2e6e:	6053      	str	r3, [r2, #4]
  }
}
    2e70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    2e72:	4e19      	ldr	r6, [pc, #100]	; (2ed8 <udc_configure_endpoint+0x134>)
    2e74:	0010      	movs	r0, r2
    2e76:	3008      	adds	r0, #8
    2e78:	0140      	lsls	r0, r0, #5
    2e7a:	5d85      	ldrb	r5, [r0, r6]
    2e7c:	2770      	movs	r7, #112	; 0x70
    2e7e:	43bd      	bics	r5, r7
    2e80:	5585      	strb	r5, [r0, r6]
    2e82:	e7a8      	b.n	2dd6 <udc_configure_endpoint+0x32>
    type = USB_DEVICE_EPCFG_EPTYPE_ISOCHRONOUS;
    2e84:	2002      	movs	r0, #2
    2e86:	e7ca      	b.n	2e1e <udc_configure_endpoint+0x7a>
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type;
    2e88:	2307      	movs	r3, #7
    2e8a:	4f13      	ldr	r7, [pc, #76]	; (2ed8 <udc_configure_endpoint+0x134>)
    2e8c:	0011      	movs	r1, r2
    2e8e:	3108      	adds	r1, #8
    2e90:	0149      	lsls	r1, r1, #5
    2e92:	5dcc      	ldrb	r4, [r1, r7]
    2e94:	4018      	ands	r0, r3
    2e96:	0106      	lsls	r6, r0, #4
    2e98:	2070      	movs	r0, #112	; 0x70
    2e9a:	4384      	bics	r4, r0
    2e9c:	0020      	movs	r0, r4
    2e9e:	4330      	orrs	r0, r6
    2ea0:	55c8      	strb	r0, [r1, r7]
    USB->DEVICE.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1;
    2ea2:	0156      	lsls	r6, r2, #5
    2ea4:	4a0d      	ldr	r2, [pc, #52]	; (2edc <udc_configure_endpoint+0x138>)
    2ea6:	18b0      	adds	r0, r6, r2
    2ea8:	7844      	ldrb	r4, [r0, #1]
    2eaa:	2202      	movs	r2, #2
    2eac:	4314      	orrs	r4, r2
    2eae:	7044      	strb	r4, [r0, #1]
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.DTGLIN = 1;
    2eb0:	46bc      	mov	ip, r7
    2eb2:	4461      	add	r1, ip
    2eb4:	7908      	ldrb	r0, [r1, #4]
    2eb6:	4310      	orrs	r0, r2
    2eb8:	7108      	strb	r0, [r1, #4]
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1;
    2eba:	790a      	ldrb	r2, [r1, #4]
    2ebc:	2080      	movs	r0, #128	; 0x80
    2ebe:	4240      	negs	r0, r0
    2ec0:	4310      	orrs	r0, r2
    2ec2:	7108      	strb	r0, [r1, #4]
    udc_mem[ep].in.PCKSIZE.bit.SIZE = size;
    2ec4:	4a06      	ldr	r2, [pc, #24]	; (2ee0 <udc_configure_endpoint+0x13c>)
    2ec6:	1992      	adds	r2, r2, r6
    2ec8:	6951      	ldr	r1, [r2, #20]
    2eca:	402b      	ands	r3, r5
    2ecc:	071b      	lsls	r3, r3, #28
    2ece:	4d05      	ldr	r5, [pc, #20]	; (2ee4 <udc_configure_endpoint+0x140>)
    2ed0:	400d      	ands	r5, r1
    2ed2:	432b      	orrs	r3, r5
    2ed4:	6153      	str	r3, [r2, #20]
    2ed6:	e7cb      	b.n	2e70 <udc_configure_endpoint+0xcc>
    2ed8:	41005000 	.word	0x41005000
    2edc:	41005108 	.word	0x41005108
    2ee0:	20000234 	.word	0x20000234
    2ee4:	8fffffff 	.word	0x8fffffff

00002ee8 <udc_endpoint_configured>:

//-----------------------------------------------------------------------------
bool udc_endpoint_configured(int ep, int dir)
{
  if (USB_IN_ENDPOINT == dir)
    2ee8:	2980      	cmp	r1, #128	; 0x80
    2eea:	d008      	beq.n	2efe <udc_endpoint_configured+0x16>
    return (USB_DEVICE_EPCFG_EPTYPE_DISABLED != USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1);
  else
    return (USB_DEVICE_EPCFG_EPTYPE_DISABLED != USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0);
    2eec:	3008      	adds	r0, #8
    2eee:	0140      	lsls	r0, r0, #5
    2ef0:	4b08      	ldr	r3, [pc, #32]	; (2f14 <udc_endpoint_configured+0x2c>)
    2ef2:	5cc0      	ldrb	r0, [r0, r3]
    2ef4:	0740      	lsls	r0, r0, #29
    2ef6:	1e43      	subs	r3, r0, #1
    2ef8:	4198      	sbcs	r0, r3
    2efa:	b2c0      	uxtb	r0, r0
}
    2efc:	4770      	bx	lr
    return (USB_DEVICE_EPCFG_EPTYPE_DISABLED != USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1);
    2efe:	3008      	adds	r0, #8
    2f00:	0140      	lsls	r0, r0, #5
    2f02:	4b04      	ldr	r3, [pc, #16]	; (2f14 <udc_endpoint_configured+0x2c>)
    2f04:	5cc0      	ldrb	r0, [r0, r3]
    2f06:	0640      	lsls	r0, r0, #25
    2f08:	0f40      	lsrs	r0, r0, #29
    2f0a:	1e43      	subs	r3, r0, #1
    2f0c:	4198      	sbcs	r0, r3
    2f0e:	b2c0      	uxtb	r0, r0
    2f10:	e7f4      	b.n	2efc <udc_endpoint_configured+0x14>
    2f12:	46c0      	nop			; (mov r8, r8)
    2f14:	41005000 	.word	0x41005000

00002f18 <udc_endpoint_get_status>:

//-----------------------------------------------------------------------------
int udc_endpoint_get_status(int ep, int dir)
{
  if (USB_IN_ENDPOINT == dir)
    2f18:	2980      	cmp	r1, #128	; 0x80
    2f1a:	d007      	beq.n	2f2c <udc_endpoint_get_status+0x14>
    return USB->DEVICE.DeviceEndpoint[ep].EPSTATUS.bit.STALLRQ1;
  else
    return USB->DEVICE.DeviceEndpoint[ep].EPSTATUS.bit.STALLRQ0;
    2f1c:	0140      	lsls	r0, r0, #5
    2f1e:	4b07      	ldr	r3, [pc, #28]	; (2f3c <udc_endpoint_get_status+0x24>)
    2f20:	469c      	mov	ip, r3
    2f22:	4460      	add	r0, ip
    2f24:	7980      	ldrb	r0, [r0, #6]
    2f26:	06c0      	lsls	r0, r0, #27
    2f28:	0fc0      	lsrs	r0, r0, #31
}
    2f2a:	4770      	bx	lr
    return USB->DEVICE.DeviceEndpoint[ep].EPSTATUS.bit.STALLRQ1;
    2f2c:	0140      	lsls	r0, r0, #5
    2f2e:	4b03      	ldr	r3, [pc, #12]	; (2f3c <udc_endpoint_get_status+0x24>)
    2f30:	469c      	mov	ip, r3
    2f32:	4460      	add	r0, ip
    2f34:	7980      	ldrb	r0, [r0, #6]
    2f36:	0680      	lsls	r0, r0, #26
    2f38:	0fc0      	lsrs	r0, r0, #31
    2f3a:	e7f6      	b.n	2f2a <udc_endpoint_get_status+0x12>
    2f3c:	41005100 	.word	0x41005100

00002f40 <udc_endpoint_set_feature>:

//-----------------------------------------------------------------------------
void udc_endpoint_set_feature(int ep, int dir)
{
  if (USB_IN_ENDPOINT == dir)
    2f40:	2980      	cmp	r1, #128	; 0x80
    2f42:	d008      	beq.n	2f56 <udc_endpoint_set_feature+0x16>
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1;
  else
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ0 = 1;
    2f44:	0140      	lsls	r0, r0, #5
    2f46:	4b08      	ldr	r3, [pc, #32]	; (2f68 <udc_endpoint_set_feature+0x28>)
    2f48:	469c      	mov	ip, r3
    2f4a:	4460      	add	r0, ip
    2f4c:	7943      	ldrb	r3, [r0, #5]
    2f4e:	2210      	movs	r2, #16
    2f50:	4313      	orrs	r3, r2
    2f52:	7143      	strb	r3, [r0, #5]
}
    2f54:	4770      	bx	lr
    USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1;
    2f56:	0140      	lsls	r0, r0, #5
    2f58:	4b03      	ldr	r3, [pc, #12]	; (2f68 <udc_endpoint_set_feature+0x28>)
    2f5a:	469c      	mov	ip, r3
    2f5c:	4460      	add	r0, ip
    2f5e:	7943      	ldrb	r3, [r0, #5]
    2f60:	2220      	movs	r2, #32
    2f62:	4313      	orrs	r3, r2
    2f64:	7143      	strb	r3, [r0, #5]
    2f66:	e7f5      	b.n	2f54 <udc_endpoint_set_feature+0x14>
    2f68:	41005100 	.word	0x41005100

00002f6c <udc_endpoint_clear_feature>:

//-----------------------------------------------------------------------------
void udc_endpoint_clear_feature(int ep, int dir)
{
  if (USB_IN_ENDPOINT == dir)
    2f6c:	2980      	cmp	r1, #128	; 0x80
    2f6e:	d018      	beq.n	2fa2 <udc_endpoint_clear_feature+0x36>
      }
    }
  }
  else
  {
    if (USB->DEVICE.DeviceEndpoint[ep].EPSTATUS.bit.STALLRQ0)
    2f70:	0143      	lsls	r3, r0, #5
    2f72:	4a18      	ldr	r2, [pc, #96]	; (2fd4 <udc_endpoint_clear_feature+0x68>)
    2f74:	4694      	mov	ip, r2
    2f76:	4463      	add	r3, ip
    2f78:	799b      	ldrb	r3, [r3, #6]
    2f7a:	06db      	lsls	r3, r3, #27
    2f7c:	d510      	bpl.n	2fa0 <udc_endpoint_clear_feature+0x34>
    {
      USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1;
    2f7e:	0143      	lsls	r3, r0, #5
    2f80:	4463      	add	r3, ip
    2f82:	791a      	ldrb	r2, [r3, #4]
    2f84:	2110      	movs	r1, #16
    2f86:	430a      	orrs	r2, r1
    2f88:	711a      	strb	r2, [r3, #4]

      if (USB->DEVICE.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0)
    2f8a:	79db      	ldrb	r3, [r3, #7]
    2f8c:	069b      	lsls	r3, r3, #26
    2f8e:	d507      	bpl.n	2fa0 <udc_endpoint_clear_feature+0x34>
      {
        USB->DEVICE.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL0;
    2f90:	0140      	lsls	r0, r0, #5
    2f92:	4460      	add	r0, ip
    2f94:	2320      	movs	r3, #32
    2f96:	71c3      	strb	r3, [r0, #7]
        USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.DTGLOUT = 1;
    2f98:	7903      	ldrb	r3, [r0, #4]
    2f9a:	2201      	movs	r2, #1
    2f9c:	4313      	orrs	r3, r2
    2f9e:	7103      	strb	r3, [r0, #4]
      }
    }
  }
}
    2fa0:	4770      	bx	lr
    if (USB->DEVICE.DeviceEndpoint[ep].EPSTATUS.bit.STALLRQ1)
    2fa2:	0143      	lsls	r3, r0, #5
    2fa4:	4a0b      	ldr	r2, [pc, #44]	; (2fd4 <udc_endpoint_clear_feature+0x68>)
    2fa6:	4694      	mov	ip, r2
    2fa8:	4463      	add	r3, ip
    2faa:	799b      	ldrb	r3, [r3, #6]
    2fac:	069b      	lsls	r3, r3, #26
    2fae:	d5f7      	bpl.n	2fa0 <udc_endpoint_clear_feature+0x34>
      USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1;
    2fb0:	0143      	lsls	r3, r0, #5
    2fb2:	4463      	add	r3, ip
    2fb4:	791a      	ldrb	r2, [r3, #4]
    2fb6:	2120      	movs	r1, #32
    2fb8:	430a      	orrs	r2, r1
    2fba:	711a      	strb	r2, [r3, #4]
      if (USB->DEVICE.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1)
    2fbc:	79db      	ldrb	r3, [r3, #7]
    2fbe:	065b      	lsls	r3, r3, #25
    2fc0:	d5ee      	bpl.n	2fa0 <udc_endpoint_clear_feature+0x34>
        USB->DEVICE.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL1;
    2fc2:	0140      	lsls	r0, r0, #5
    2fc4:	4460      	add	r0, ip
    2fc6:	2340      	movs	r3, #64	; 0x40
    2fc8:	71c3      	strb	r3, [r0, #7]
        USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.DTGLIN = 1;
    2fca:	7903      	ldrb	r3, [r0, #4]
    2fcc:	2202      	movs	r2, #2
    2fce:	4313      	orrs	r3, r2
    2fd0:	7103      	strb	r3, [r0, #4]
    2fd2:	e7e5      	b.n	2fa0 <udc_endpoint_clear_feature+0x34>
    2fd4:	41005100 	.word	0x41005100

00002fd8 <udc_set_address>:

//-----------------------------------------------------------------------------
void udc_set_address(int address)
{
  USB->DEVICE.DADD.reg = USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(address);
    2fd8:	2380      	movs	r3, #128	; 0x80
    2fda:	425b      	negs	r3, r3
    2fdc:	4318      	orrs	r0, r3
    2fde:	b2c0      	uxtb	r0, r0
    2fe0:	4b01      	ldr	r3, [pc, #4]	; (2fe8 <udc_set_address+0x10>)
    2fe2:	7298      	strb	r0, [r3, #10]
}
    2fe4:	4770      	bx	lr
    2fe6:	46c0      	nop			; (mov r8, r8)
    2fe8:	41005000 	.word	0x41005000

00002fec <udc_send>:

//-----------------------------------------------------------------------------
void udc_send(int ep, uint8_t *data, int size)
{
    2fec:	b510      	push	{r4, lr}
  udc_mem[ep].in.ADDR.reg = (uint32_t)data;
    2fee:	0144      	lsls	r4, r0, #5
    2ff0:	4b0c      	ldr	r3, [pc, #48]	; (3024 <udc_send+0x38>)
    2ff2:	191b      	adds	r3, r3, r4
    2ff4:	001c      	movs	r4, r3
    2ff6:	6119      	str	r1, [r3, #16]
  udc_mem[ep].in.PCKSIZE.bit.BYTE_COUNT = size;
    2ff8:	695b      	ldr	r3, [r3, #20]
    2ffa:	0492      	lsls	r2, r2, #18
    2ffc:	0c91      	lsrs	r1, r2, #18
    2ffe:	0b9a      	lsrs	r2, r3, #14
    3000:	0392      	lsls	r2, r2, #14
    3002:	430a      	orrs	r2, r1
    3004:	6162      	str	r2, [r4, #20]
  udc_mem[ep].in.PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
    3006:	6963      	ldr	r3, [r4, #20]
    3008:	4a07      	ldr	r2, [pc, #28]	; (3028 <udc_send+0x3c>)
    300a:	4013      	ands	r3, r2
    300c:	6163      	str	r3, [r4, #20]

  USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1;
    300e:	0140      	lsls	r0, r0, #5
    3010:	4b06      	ldr	r3, [pc, #24]	; (302c <udc_send+0x40>)
    3012:	469c      	mov	ip, r3
    3014:	4460      	add	r0, ip
    3016:	7942      	ldrb	r2, [r0, #5]
    3018:	2380      	movs	r3, #128	; 0x80
    301a:	425b      	negs	r3, r3
    301c:	4313      	orrs	r3, r2
    301e:	7143      	strb	r3, [r0, #5]
}
    3020:	bd10      	pop	{r4, pc}
    3022:	46c0      	nop			; (mov r8, r8)
    3024:	20000234 	.word	0x20000234
    3028:	f0003fff 	.word	0xf0003fff
    302c:	41005100 	.word	0x41005100

00003030 <udc_recv>:

//-----------------------------------------------------------------------------
void udc_recv(int ep, uint8_t *data, int size)
{
    3030:	b510      	push	{r4, lr}
  udc_mem[ep].out.ADDR.reg = (uint32_t)data;
    3032:	4b0c      	ldr	r3, [pc, #48]	; (3064 <udc_recv+0x34>)
    3034:	0144      	lsls	r4, r0, #5
    3036:	50e1      	str	r1, [r4, r3]
  udc_mem[ep].out.PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    3038:	191b      	adds	r3, r3, r4
    303a:	6859      	ldr	r1, [r3, #4]
    303c:	0492      	lsls	r2, r2, #18
    303e:	0914      	lsrs	r4, r2, #4
    3040:	4a09      	ldr	r2, [pc, #36]	; (3068 <udc_recv+0x38>)
    3042:	400a      	ands	r2, r1
    3044:	4322      	orrs	r2, r4
    3046:	605a      	str	r2, [r3, #4]
  udc_mem[ep].out.PCKSIZE.bit.BYTE_COUNT = 0;
    3048:	685a      	ldr	r2, [r3, #4]
    304a:	0b92      	lsrs	r2, r2, #14
    304c:	0392      	lsls	r2, r2, #14
    304e:	605a      	str	r2, [r3, #4]

  USB->DEVICE.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1;
    3050:	0140      	lsls	r0, r0, #5
    3052:	4b06      	ldr	r3, [pc, #24]	; (306c <udc_recv+0x3c>)
    3054:	469c      	mov	ip, r3
    3056:	4460      	add	r0, ip
    3058:	7903      	ldrb	r3, [r0, #4]
    305a:	2240      	movs	r2, #64	; 0x40
    305c:	4313      	orrs	r3, r2
    305e:	7103      	strb	r3, [r0, #4]
}
    3060:	bd10      	pop	{r4, pc}
    3062:	46c0      	nop			; (mov r8, r8)
    3064:	20000234 	.word	0x20000234
    3068:	f0003fff 	.word	0xf0003fff
    306c:	41005100 	.word	0x41005100

00003070 <udc_control_send_zlp>:

//-----------------------------------------------------------------------------
void udc_control_send_zlp(void)
{
  udc_mem[0].in.PCKSIZE.bit.BYTE_COUNT = 0;
    3070:	4a0b      	ldr	r2, [pc, #44]	; (30a0 <udc_control_send_zlp+0x30>)
    3072:	6953      	ldr	r3, [r2, #20]
    3074:	0b9b      	lsrs	r3, r3, #14
    3076:	039b      	lsls	r3, r3, #14
    3078:	6153      	str	r3, [r2, #20]
  USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
    307a:	4b0a      	ldr	r3, [pc, #40]	; (30a4 <udc_control_send_zlp+0x34>)
    307c:	2102      	movs	r1, #2
    307e:	2208      	movs	r2, #8
    3080:	32ff      	adds	r2, #255	; 0xff
    3082:	5499      	strb	r1, [r3, r2]
  USB->DEVICE.DeviceEndpoint[0].EPSTATUSSET.bit.BK1RDY = 1;
    3084:	2106      	movs	r1, #6
    3086:	31ff      	adds	r1, #255	; 0xff
    3088:	5c58      	ldrb	r0, [r3, r1]
    308a:	3a88      	subs	r2, #136	; 0x88
    308c:	3aff      	subs	r2, #255	; 0xff
    308e:	4302      	orrs	r2, r0
    3090:	545a      	strb	r2, [r3, r1]

  while (0 == USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.bit.TRCPT1);
    3092:	0019      	movs	r1, r3
    3094:	2208      	movs	r2, #8
    3096:	32ff      	adds	r2, #255	; 0xff
    3098:	5c8b      	ldrb	r3, [r1, r2]
    309a:	079b      	lsls	r3, r3, #30
    309c:	d5fc      	bpl.n	3098 <udc_control_send_zlp+0x28>
}
    309e:	4770      	bx	lr
    30a0:	20000234 	.word	0x20000234
    30a4:	41005000 	.word	0x41005000

000030a8 <udc_control_stall>:

//-----------------------------------------------------------------------------
void udc_control_stall(void)
{
  USB->DEVICE.DeviceEndpoint[0].EPSTATUSSET.bit.STALLRQ1 = 1;
    30a8:	4903      	ldr	r1, [pc, #12]	; (30b8 <udc_control_stall+0x10>)
    30aa:	2206      	movs	r2, #6
    30ac:	32ff      	adds	r2, #255	; 0xff
    30ae:	5c8b      	ldrb	r3, [r1, r2]
    30b0:	2020      	movs	r0, #32
    30b2:	4303      	orrs	r3, r0
    30b4:	548b      	strb	r3, [r1, r2]
}
    30b6:	4770      	bx	lr
    30b8:	41005000 	.word	0x41005000

000030bc <udc_control_send>:

//-----------------------------------------------------------------------------
void udc_control_send(uint8_t *data, int size)
{
    30bc:	b570      	push	{r4, r5, r6, lr}
    30be:	000c      	movs	r4, r1
  if (size <= usb_device_descriptor.bMaxPacketSize0)
    30c0:	4b16      	ldr	r3, [pc, #88]	; (311c <udc_control_send+0x60>)
    30c2:	79db      	ldrb	r3, [r3, #7]
    30c4:	428b      	cmp	r3, r1
    30c6:	da20      	bge.n	310a <udc_control_send+0x4e>
    udc_mem[0].in.ADDR.reg = (uint32_t)udc_ctrl_in_buf;
  }
  else
  {
    // Large payloads must be aligned
    udc_mem[0].in.ADDR.reg = (uint32_t)data;
    30c8:	4b15      	ldr	r3, [pc, #84]	; (3120 <udc_control_send+0x64>)
    30ca:	6118      	str	r0, [r3, #16]
  }

  udc_mem[0].in.PCKSIZE.bit.BYTE_COUNT = size;
    30cc:	4b14      	ldr	r3, [pc, #80]	; (3120 <udc_control_send+0x64>)
    30ce:	6959      	ldr	r1, [r3, #20]
    30d0:	04a4      	lsls	r4, r4, #18
    30d2:	0ca4      	lsrs	r4, r4, #18
    30d4:	0b89      	lsrs	r1, r1, #14
    30d6:	0389      	lsls	r1, r1, #14
    30d8:	4321      	orrs	r1, r4
    30da:	6159      	str	r1, [r3, #20]
  udc_mem[0].in.PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
    30dc:	695a      	ldr	r2, [r3, #20]
    30de:	4911      	ldr	r1, [pc, #68]	; (3124 <udc_control_send+0x68>)
    30e0:	400a      	ands	r2, r1
    30e2:	615a      	str	r2, [r3, #20]

  USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
    30e4:	4b10      	ldr	r3, [pc, #64]	; (3128 <udc_control_send+0x6c>)
    30e6:	2102      	movs	r1, #2
    30e8:	2208      	movs	r2, #8
    30ea:	32ff      	adds	r2, #255	; 0xff
    30ec:	5499      	strb	r1, [r3, r2]
  USB->DEVICE.DeviceEndpoint[0].EPSTATUSSET.bit.BK1RDY = 1;
    30ee:	2106      	movs	r1, #6
    30f0:	31ff      	adds	r1, #255	; 0xff
    30f2:	5c58      	ldrb	r0, [r3, r1]
    30f4:	3a88      	subs	r2, #136	; 0x88
    30f6:	3aff      	subs	r2, #255	; 0xff
    30f8:	4302      	orrs	r2, r0
    30fa:	545a      	strb	r2, [r3, r1]

  while (0 == USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.bit.TRCPT1);
    30fc:	0019      	movs	r1, r3
    30fe:	2208      	movs	r2, #8
    3100:	32ff      	adds	r2, #255	; 0xff
    3102:	5c8b      	ldrb	r3, [r1, r2]
    3104:	079b      	lsls	r3, r3, #30
    3106:	d5fc      	bpl.n	3102 <udc_control_send+0x46>
}
    3108:	bd70      	pop	{r4, r5, r6, pc}
    memcpy((void*)udc_ctrl_in_buf, data, size);
    310a:	4d08      	ldr	r5, [pc, #32]	; (312c <udc_control_send+0x70>)
    310c:	000a      	movs	r2, r1
    310e:	0001      	movs	r1, r0
    3110:	0028      	movs	r0, r5
    3112:	4b07      	ldr	r3, [pc, #28]	; (3130 <udc_control_send+0x74>)
    3114:	4798      	blx	r3
    udc_mem[0].in.ADDR.reg = (uint32_t)udc_ctrl_in_buf;
    3116:	4b02      	ldr	r3, [pc, #8]	; (3120 <udc_control_send+0x64>)
    3118:	611d      	str	r5, [r3, #16]
    311a:	e7d7      	b.n	30cc <udc_control_send+0x10>
    311c:	20000088 	.word	0x20000088
    3120:	20000234 	.word	0x20000234
    3124:	f0003fff 	.word	0xf0003fff
    3128:	41005000 	.word	0x41005000
    312c:	200001b4 	.word	0x200001b4
    3130:	000039ed 	.word	0x000039ed

00003134 <USB_Handler>:

//-----------------------------------------------------------------------------
void USB_Handler(void)
{
    3134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3136:	46ce      	mov	lr, r9
    3138:	4647      	mov	r7, r8
    313a:	b580      	push	{r7, lr}
  int epint, flags;

  if (USB->DEVICE.INTFLAG.bit.EORST)
    313c:	4b5f      	ldr	r3, [pc, #380]	; (32bc <USB_Handler+0x188>)
    313e:	8b9b      	ldrh	r3, [r3, #28]
    3140:	071b      	lsls	r3, r3, #28
    3142:	d553      	bpl.n	31ec <USB_Handler+0xb8>
  {
    USB->DEVICE.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST;
    3144:	4b5d      	ldr	r3, [pc, #372]	; (32bc <USB_Handler+0x188>)
    3146:	2208      	movs	r2, #8
    3148:	839a      	strh	r2, [r3, #28]
    USB->DEVICE.DADD.reg = USB_DEVICE_DADD_ADDEN;
    314a:	3278      	adds	r2, #120	; 0x78
    314c:	729a      	strb	r2, [r3, #10]

    for (int i = 0; i < USB_EPT_NUM; i++)
    314e:	2100      	movs	r1, #0
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    3150:	001a      	movs	r2, r3
    3152:	2570      	movs	r5, #112	; 0x70
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    3154:	2407      	movs	r4, #7
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    3156:	000b      	movs	r3, r1
    3158:	3308      	adds	r3, #8
    315a:	015b      	lsls	r3, r3, #5
    315c:	5c98      	ldrb	r0, [r3, r2]
    315e:	43a8      	bics	r0, r5
    3160:	5498      	strb	r0, [r3, r2]
    USB->DEVICE.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = USB_DEVICE_EPCFG_EPTYPE_DISABLED;
    3162:	5c98      	ldrb	r0, [r3, r2]
    3164:	43a0      	bics	r0, r4
    3166:	5498      	strb	r0, [r3, r2]
    for (int i = 0; i < USB_EPT_NUM; i++)
    3168:	3101      	adds	r1, #1
    316a:	2908      	cmp	r1, #8
    316c:	d1f3      	bne.n	3156 <USB_Handler+0x22>
    {
      udc_reset_endpoint(i, USB_IN_ENDPOINT);
      udc_reset_endpoint(i, USB_OUT_ENDPOINT);
    }

    USB->DEVICE.DeviceEndpoint[0].EPCFG.reg =
    316e:	4a53      	ldr	r2, [pc, #332]	; (32bc <USB_Handler+0x188>)
    3170:	3109      	adds	r1, #9
    3172:	2380      	movs	r3, #128	; 0x80
    3174:	005b      	lsls	r3, r3, #1
    3176:	54d1      	strb	r1, [r2, r3]
        USB_DEVICE_EPCFG_EPTYPE0(USB_DEVICE_EPCFG_EPTYPE_CONTROL) |
        USB_DEVICE_EPCFG_EPTYPE1(USB_DEVICE_EPCFG_EPTYPE_CONTROL);
    USB->DEVICE.DeviceEndpoint[0].EPSTATUSSET.bit.BK0RDY = 1;
    3178:	2106      	movs	r1, #6
    317a:	31ff      	adds	r1, #255	; 0xff
    317c:	5c53      	ldrb	r3, [r2, r1]
    317e:	2440      	movs	r4, #64	; 0x40
    3180:	4323      	orrs	r3, r4
    3182:	5453      	strb	r3, [r2, r1]
    USB->DEVICE.DeviceEndpoint[0].EPSTATUSCLR.bit.BK1RDY = 1;
    3184:	2082      	movs	r0, #130	; 0x82
    3186:	0040      	lsls	r0, r0, #1
    3188:	5c11      	ldrb	r1, [r2, r0]
    318a:	2380      	movs	r3, #128	; 0x80
    318c:	425b      	negs	r3, r3
    318e:	430b      	orrs	r3, r1
    3190:	5413      	strb	r3, [r2, r0]

    udc_mem[0].in.ADDR.reg = (uint32_t)udc_ctrl_in_buf;
    3192:	4b4b      	ldr	r3, [pc, #300]	; (32c0 <USB_Handler+0x18c>)
    3194:	494b      	ldr	r1, [pc, #300]	; (32c4 <USB_Handler+0x190>)
    3196:	6119      	str	r1, [r3, #16]
    udc_mem[0].in.PCKSIZE.bit.SIZE = USB_DEVICE_PCKSIZE_SIZE_64;
    3198:	6959      	ldr	r1, [r3, #20]
    319a:	4f4b      	ldr	r7, [pc, #300]	; (32c8 <USB_Handler+0x194>)
    319c:	4039      	ands	r1, r7
    319e:	25c0      	movs	r5, #192	; 0xc0
    31a0:	05ad      	lsls	r5, r5, #22
    31a2:	4329      	orrs	r1, r5
    31a4:	6159      	str	r1, [r3, #20]
    udc_mem[0].in.PCKSIZE.bit.BYTE_COUNT = 0;
    31a6:	6959      	ldr	r1, [r3, #20]
    31a8:	0b89      	lsrs	r1, r1, #14
    31aa:	0389      	lsls	r1, r1, #14
    31ac:	6159      	str	r1, [r3, #20]
    udc_mem[0].in.PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
    31ae:	695e      	ldr	r6, [r3, #20]
    31b0:	4946      	ldr	r1, [pc, #280]	; (32cc <USB_Handler+0x198>)
    31b2:	468c      	mov	ip, r1
    31b4:	400e      	ands	r6, r1
    31b6:	615e      	str	r6, [r3, #20]

    udc_mem[0].out.ADDR.reg = (uint32_t)udc_ctrl_out_buf;
    31b8:	4945      	ldr	r1, [pc, #276]	; (32d0 <USB_Handler+0x19c>)
    31ba:	6019      	str	r1, [r3, #0]
    udc_mem[0].out.PCKSIZE.bit.SIZE = USB_DEVICE_PCKSIZE_SIZE_64;
    31bc:	685e      	ldr	r6, [r3, #4]
    31be:	403e      	ands	r6, r7
    31c0:	4335      	orrs	r5, r6
    31c2:	605d      	str	r5, [r3, #4]
    udc_mem[0].out.PCKSIZE.bit.MULTI_PACKET_SIZE = 8;
    31c4:	685d      	ldr	r5, [r3, #4]
    31c6:	4661      	mov	r1, ip
    31c8:	400d      	ands	r5, r1
    31ca:	2180      	movs	r1, #128	; 0x80
    31cc:	0289      	lsls	r1, r1, #10
    31ce:	4329      	orrs	r1, r5
    31d0:	6059      	str	r1, [r3, #4]
    udc_mem[0].out.PCKSIZE.bit.BYTE_COUNT = 0;
    31d2:	6859      	ldr	r1, [r3, #4]
    31d4:	0b89      	lsrs	r1, r1, #14
    31d6:	0389      	lsls	r1, r1, #14
    31d8:	6059      	str	r1, [r3, #4]

    USB->DEVICE.DeviceEndpoint[0].EPSTATUSCLR.bit.BK0RDY = 1;
    31da:	5c13      	ldrb	r3, [r2, r0]
    31dc:	431c      	orrs	r4, r3
    31de:	5414      	strb	r4, [r2, r0]
    USB->DEVICE.DeviceEndpoint[0].EPINTENSET.bit.RXSTP = 1;
    31e0:	210a      	movs	r1, #10
    31e2:	31ff      	adds	r1, #255	; 0xff
    31e4:	5c53      	ldrb	r3, [r2, r1]
    31e6:	2010      	movs	r0, #16
    31e8:	4303      	orrs	r3, r0
    31ea:	5453      	strb	r3, [r2, r1]
  }

  if (USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.bit.RXSTP)
    31ec:	2308      	movs	r3, #8
    31ee:	33ff      	adds	r3, #255	; 0xff
    31f0:	4a32      	ldr	r2, [pc, #200]	; (32bc <USB_Handler+0x188>)
    31f2:	5cd3      	ldrb	r3, [r2, r3]
    31f4:	06db      	lsls	r3, r3, #27
    31f6:	d40a      	bmi.n	320e <USB_Handler+0xda>
    //USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
    usb_handle_standard_request((usb_request_t *)udc_ctrl_out_buf);
    USB->DEVICE.DeviceEndpoint[0].EPSTATUSCLR.bit.BK0RDY = 1;
  }

  epint = USB->DEVICE.EPINTSMRY.reg;
    31f8:	4b30      	ldr	r3, [pc, #192]	; (32bc <USB_Handler+0x188>)
    31fa:	8c1d      	ldrh	r5, [r3, #32]
    31fc:	b2ad      	uxth	r5, r5

  for (int i = 0; epint && i < USB_EPT_NUM; i++)
    31fe:	2601      	movs	r6, #1
    3200:	2400      	movs	r4, #0
    3202:	2d00      	cmp	r5, #0
    3204:	d11f      	bne.n	3246 <USB_Handler+0x112>
          comms_usb_raw_hid_send_callback();
      }
      //udc_send_callback(i);
    }
  }
}
    3206:	bc0c      	pop	{r2, r3}
    3208:	4690      	mov	r8, r2
    320a:	4699      	mov	r9, r3
    320c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP;
    320e:	0014      	movs	r4, r2
    3210:	2210      	movs	r2, #16
    3212:	2308      	movs	r3, #8
    3214:	33ff      	adds	r3, #255	; 0xff
    3216:	54e2      	strb	r2, [r4, r3]
    usb_handle_standard_request((usb_request_t *)udc_ctrl_out_buf);
    3218:	482d      	ldr	r0, [pc, #180]	; (32d0 <USB_Handler+0x19c>)
    321a:	4b2e      	ldr	r3, [pc, #184]	; (32d4 <USB_Handler+0x1a0>)
    321c:	4798      	blx	r3
    USB->DEVICE.DeviceEndpoint[0].EPSTATUSCLR.bit.BK0RDY = 1;
    321e:	2282      	movs	r2, #130	; 0x82
    3220:	0052      	lsls	r2, r2, #1
    3222:	5ca3      	ldrb	r3, [r4, r2]
    3224:	2140      	movs	r1, #64	; 0x40
    3226:	430b      	orrs	r3, r1
    3228:	54a3      	strb	r3, [r4, r2]
    322a:	e7e5      	b.n	31f8 <USB_Handler+0xc4>
          comms_usb_raw_hid_recv_callback(udc_mem[i].out.PCKSIZE.bit.BYTE_COUNT);
    322c:	4b24      	ldr	r3, [pc, #144]	; (32c0 <USB_Handler+0x18c>)
    322e:	6c58      	ldr	r0, [r3, #68]	; 0x44
    3230:	0480      	lsls	r0, r0, #18
    3232:	0c80      	lsrs	r0, r0, #18
    3234:	4b28      	ldr	r3, [pc, #160]	; (32d8 <USB_Handler+0x1a4>)
    3236:	4798      	blx	r3
    3238:	e026      	b.n	3288 <USB_Handler+0x154>
  for (int i = 0; epint && i < USB_EPT_NUM; i++)
    323a:	2d00      	cmp	r5, #0
    323c:	d0e3      	beq.n	3206 <USB_Handler+0xd2>
    323e:	2e07      	cmp	r6, #7
    3240:	dce1      	bgt.n	3206 <USB_Handler+0xd2>
    3242:	3401      	adds	r4, #1
    3244:	3601      	adds	r6, #1
    3246:	46a1      	mov	r9, r4
    if (0 == (epint & (1 << i)))
    3248:	002b      	movs	r3, r5
    324a:	4123      	asrs	r3, r4
    324c:	07db      	lsls	r3, r3, #31
    324e:	d5f4      	bpl.n	323a <USB_Handler+0x106>
    epint &= ~(1 << i);
    3250:	2301      	movs	r3, #1
    3252:	40a3      	lsls	r3, r4
    3254:	439d      	bics	r5, r3
    3256:	0167      	lsls	r7, r4, #5
    3258:	4b18      	ldr	r3, [pc, #96]	; (32bc <USB_Handler+0x188>)
    325a:	469c      	mov	ip, r3
    325c:	4467      	add	r7, ip
    flags = USB->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg;
    325e:	2308      	movs	r3, #8
    3260:	33ff      	adds	r3, #255	; 0xff
    3262:	5cfb      	ldrb	r3, [r7, r3]
    3264:	b2db      	uxtb	r3, r3
    3266:	4698      	mov	r8, r3
    if (flags & USB_DEVICE_EPINTFLAG_TRCPT0)
    3268:	07db      	lsls	r3, r3, #31
    326a:	d50d      	bpl.n	3288 <USB_Handler+0x154>
      USB->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;
    326c:	2201      	movs	r2, #1
    326e:	2308      	movs	r3, #8
    3270:	33ff      	adds	r3, #255	; 0xff
    3272:	54fa      	strb	r2, [r7, r3]
      USB->DEVICE.DeviceEndpoint[i].EPSTATUSSET.bit.BK0RDY = 1;
    3274:	0163      	lsls	r3, r4, #5
    3276:	4a19      	ldr	r2, [pc, #100]	; (32dc <USB_Handler+0x1a8>)
    3278:	4694      	mov	ip, r2
    327a:	4463      	add	r3, ip
    327c:	795a      	ldrb	r2, [r3, #5]
    327e:	2140      	movs	r1, #64	; 0x40
    3280:	430a      	orrs	r2, r1
    3282:	715a      	strb	r2, [r3, #5]
      if (i == USB_RAWHID_TX_ENDPOINT)
    3284:	2c02      	cmp	r4, #2
    3286:	d0d1      	beq.n	322c <USB_Handler+0xf8>
    if (flags & USB_DEVICE_EPINTFLAG_TRCPT1)
    3288:	4643      	mov	r3, r8
    328a:	079b      	lsls	r3, r3, #30
    328c:	d5d5      	bpl.n	323a <USB_Handler+0x106>
      USB->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
    328e:	2202      	movs	r2, #2
    3290:	2308      	movs	r3, #8
    3292:	33ff      	adds	r3, #255	; 0xff
    3294:	54fa      	strb	r2, [r7, r3]
      USB->DEVICE.DeviceEndpoint[i].EPSTATUSCLR.bit.BK1RDY = 1;
    3296:	464b      	mov	r3, r9
    3298:	015b      	lsls	r3, r3, #5
    329a:	4a10      	ldr	r2, [pc, #64]	; (32dc <USB_Handler+0x1a8>)
    329c:	4694      	mov	ip, r2
    329e:	4463      	add	r3, ip
    32a0:	7919      	ldrb	r1, [r3, #4]
    32a2:	2280      	movs	r2, #128	; 0x80
    32a4:	4252      	negs	r2, r2
    32a6:	430a      	orrs	r2, r1
    32a8:	711a      	strb	r2, [r3, #4]
      if (i == USB_RAWHID_RX_ENDPOINT)
    32aa:	464b      	mov	r3, r9
    32ac:	2b01      	cmp	r3, #1
    32ae:	d1c4      	bne.n	323a <USB_Handler+0x106>
          comms_usb_raw_hid_send_callback();
    32b0:	4b0b      	ldr	r3, [pc, #44]	; (32e0 <USB_Handler+0x1ac>)
    32b2:	4798      	blx	r3
  for (int i = 0; epint && i < USB_EPT_NUM; i++)
    32b4:	2d00      	cmp	r5, #0
    32b6:	d1c4      	bne.n	3242 <USB_Handler+0x10e>
    32b8:	e7a5      	b.n	3206 <USB_Handler+0xd2>
    32ba:	46c0      	nop			; (mov r8, r8)
    32bc:	41005000 	.word	0x41005000
    32c0:	20000234 	.word	0x20000234
    32c4:	200001b4 	.word	0x200001b4
    32c8:	8fffffff 	.word	0x8fffffff
    32cc:	f0003fff 	.word	0xf0003fff
    32d0:	200001f4 	.word	0x200001f4
    32d4:	00003315 	.word	0x00003315
    32d8:	00002391 	.word	0x00002391
    32dc:	41005100 	.word	0x41005100
    32e0:	000023a5 	.word	0x000023a5

000032e4 <usb_init>:

/*- Implementations ---------------------------------------------------------*/

//-----------------------------------------------------------------------------
void usb_init(void)
{
    32e4:	b510      	push	{r4, lr}
  usb_config = 0;
    32e6:	2200      	movs	r2, #0
    32e8:	4b02      	ldr	r3, [pc, #8]	; (32f4 <usb_init+0x10>)
    32ea:	601a      	str	r2, [r3, #0]

  udc_init();
    32ec:	4b02      	ldr	r3, [pc, #8]	; (32f8 <usb_init+0x14>)
    32ee:	4798      	blx	r3
}
    32f0:	bd10      	pop	{r4, pc}
    32f2:	46c0      	nop			; (mov r8, r8)
    32f4:	20000334 	.word	0x20000334
    32f8:	00002ca9 	.word	0x00002ca9

000032fc <usb_send>:

//-----------------------------------------------------------------------------
void usb_send(int ep, uint8_t *data, int size)
{
    32fc:	b510      	push	{r4, lr}
  udc_send(ep, data, size);
    32fe:	4b01      	ldr	r3, [pc, #4]	; (3304 <usb_send+0x8>)
    3300:	4798      	blx	r3
}
    3302:	bd10      	pop	{r4, pc}
    3304:	00002fed 	.word	0x00002fed

00003308 <usb_recv>:

//-----------------------------------------------------------------------------
void usb_recv(int ep, uint8_t *data, int size)
{
    3308:	b510      	push	{r4, lr}
  udc_recv(ep, data, size);
    330a:	4b01      	ldr	r3, [pc, #4]	; (3310 <usb_recv+0x8>)
    330c:	4798      	blx	r3
}
    330e:	bd10      	pop	{r4, pc}
    3310:	00003031 	.word	0x00003031

00003314 <usb_handle_standard_request>:

//-----------------------------------------------------------------------------
void usb_handle_standard_request(usb_request_t *request)
{
    3314:	b5f0      	push	{r4, r5, r6, r7, lr}
    3316:	46c6      	mov	lr, r8
    3318:	b500      	push	{lr}
    331a:	b082      	sub	sp, #8
    331c:	0004      	movs	r4, r0
  switch ((request->bRequest << 8) | request->bmRequestType)
    331e:	7843      	ldrb	r3, [r0, #1]
    3320:	021b      	lsls	r3, r3, #8
    3322:	7802      	ldrb	r2, [r0, #0]
    3324:	4313      	orrs	r3, r2
    3326:	4ab5      	ldr	r2, [pc, #724]	; (35fc <usb_handle_standard_request+0x2e8>)
    3328:	4293      	cmp	r3, r2
    332a:	d100      	bne.n	332e <usb_handle_standard_request+0x1a>
    332c:	e11f      	b.n	356e <usb_handle_standard_request+0x25a>
    332e:	dd14      	ble.n	335a <usb_handle_standard_request+0x46>
    3330:	4ab3      	ldr	r2, [pc, #716]	; (3600 <usb_handle_standard_request+0x2ec>)
    3332:	4293      	cmp	r3, r2
    3334:	d100      	bne.n	3338 <usb_handle_standard_request+0x24>
    3336:	e191      	b.n	365c <usb_handle_standard_request+0x348>
    3338:	dc48      	bgt.n	33cc <usb_handle_standard_request+0xb8>
    333a:	3a82      	subs	r2, #130	; 0x82
    333c:	3aff      	subs	r2, #255	; 0xff
    333e:	4293      	cmp	r3, r2
    3340:	d100      	bne.n	3344 <usb_handle_standard_request+0x30>
    3342:	e0c4      	b.n	34ce <usb_handle_standard_request+0x1ba>
    3344:	3281      	adds	r2, #129	; 0x81
    3346:	32ff      	adds	r2, #255	; 0xff
    3348:	4293      	cmp	r3, r2
    334a:	d054      	beq.n	33f6 <usb_handle_standard_request+0xe2>
    334c:	4aad      	ldr	r2, [pc, #692]	; (3604 <usb_handle_standard_request+0x2f0>)
    334e:	4293      	cmp	r3, r2
    3350:	d100      	bne.n	3354 <usb_handle_standard_request+0x40>
    3352:	e10f      	b.n	3574 <usb_handle_standard_request+0x260>

    } break;

    default:
    {
      udc_control_stall();
    3354:	4bac      	ldr	r3, [pc, #688]	; (3608 <usb_handle_standard_request+0x2f4>)
    3356:	4798      	blx	r3
    } break;
  }
}
    3358:	e0c1      	b.n	34de <usb_handle_standard_request+0x1ca>
  switch ((request->bRequest << 8) | request->bmRequestType)
    335a:	2280      	movs	r2, #128	; 0x80
    335c:	0052      	lsls	r2, r2, #1
    335e:	4293      	cmp	r3, r2
    3360:	d100      	bne.n	3364 <usb_handle_standard_request+0x50>
    3362:	e126      	b.n	35b2 <usb_handle_standard_request+0x29e>
    3364:	dd0d      	ble.n	3382 <usb_handle_standard_request+0x6e>
    3366:	2281      	movs	r2, #129	; 0x81
    3368:	0052      	lsls	r2, r2, #1
    336a:	4293      	cmp	r3, r2
    336c:	d100      	bne.n	3370 <usb_handle_standard_request+0x5c>
    336e:	e126      	b.n	35be <usb_handle_standard_request+0x2aa>
    3370:	da00      	bge.n	3374 <usb_handle_standard_request+0x60>
    3372:	e121      	b.n	35b8 <usb_handle_standard_request+0x2a4>
    3374:	32ff      	adds	r2, #255	; 0xff
    3376:	32ff      	adds	r2, #255	; 0xff
    3378:	4293      	cmp	r3, r2
    337a:	d1eb      	bne.n	3354 <usb_handle_standard_request+0x40>
      udc_control_stall();
    337c:	4ba2      	ldr	r3, [pc, #648]	; (3608 <usb_handle_standard_request+0x2f4>)
    337e:	4798      	blx	r3
    } break;
    3380:	e0ad      	b.n	34de <usb_handle_standard_request+0x1ca>
  switch ((request->bRequest << 8) | request->bmRequestType)
    3382:	2b80      	cmp	r3, #128	; 0x80
    3384:	dbe6      	blt.n	3354 <usb_handle_standard_request+0x40>
    3386:	2b81      	cmp	r3, #129	; 0x81
    3388:	dc00      	bgt.n	338c <usb_handle_standard_request+0x78>
    338a:	e0e5      	b.n	3558 <usb_handle_standard_request+0x244>
    338c:	2b82      	cmp	r3, #130	; 0x82
    338e:	d1e1      	bne.n	3354 <usb_handle_standard_request+0x40>
      int ep = request->wIndex & USB_INDEX_MASK;
    3390:	7902      	ldrb	r2, [r0, #4]
    3392:	7943      	ldrb	r3, [r0, #5]
    3394:	021b      	lsls	r3, r3, #8
    3396:	4313      	orrs	r3, r2
    3398:	247f      	movs	r4, #127	; 0x7f
    339a:	401c      	ands	r4, r3
      int dir = request->wIndex & USB_DIRECTION_MASK;
    339c:	2580      	movs	r5, #128	; 0x80
    339e:	401d      	ands	r5, r3
      uint16_t status = 0;
    33a0:	2200      	movs	r2, #0
    33a2:	466b      	mov	r3, sp
    33a4:	80da      	strh	r2, [r3, #6]
      if (udc_endpoint_configured(ep, dir))
    33a6:	0029      	movs	r1, r5
    33a8:	0020      	movs	r0, r4
    33aa:	4b98      	ldr	r3, [pc, #608]	; (360c <usb_handle_standard_request+0x2f8>)
    33ac:	4798      	blx	r3
    33ae:	2800      	cmp	r0, #0
    33b0:	d100      	bne.n	33b4 <usb_handle_standard_request+0xa0>
    33b2:	e0d9      	b.n	3568 <usb_handle_standard_request+0x254>
        status = udc_endpoint_get_status(ep, dir);
    33b4:	0029      	movs	r1, r5
    33b6:	0020      	movs	r0, r4
    33b8:	4b95      	ldr	r3, [pc, #596]	; (3610 <usb_handle_standard_request+0x2fc>)
    33ba:	4798      	blx	r3
    33bc:	466b      	mov	r3, sp
    33be:	80d8      	strh	r0, [r3, #6]
    33c0:	3306      	adds	r3, #6
        udc_control_send((uint8_t *)&status, sizeof(status));
    33c2:	2102      	movs	r1, #2
    33c4:	0018      	movs	r0, r3
    33c6:	4b93      	ldr	r3, [pc, #588]	; (3614 <usb_handle_standard_request+0x300>)
    33c8:	4798      	blx	r3
    33ca:	e088      	b.n	34de <usb_handle_standard_request+0x1ca>
  switch ((request->bRequest << 8) | request->bmRequestType)
    33cc:	2290      	movs	r2, #144	; 0x90
    33ce:	0112      	lsls	r2, r2, #4
    33d0:	4293      	cmp	r3, r2
    33d2:	d100      	bne.n	33d6 <usb_handle_standard_request+0xc2>
    33d4:	e09c      	b.n	3510 <usb_handle_standard_request+0x1fc>
    33d6:	4a90      	ldr	r2, [pc, #576]	; (3618 <usb_handle_standard_request+0x304>)
    33d8:	4293      	cmp	r3, r2
    33da:	d100      	bne.n	33de <usb_handle_standard_request+0xca>
    33dc:	e083      	b.n	34e6 <usb_handle_standard_request+0x1d2>
    33de:	3aa1      	subs	r2, #161	; 0xa1
    33e0:	4293      	cmp	r3, r2
    33e2:	d1b7      	bne.n	3354 <usb_handle_standard_request+0x40>
      uint8_t config = usb_config;
    33e4:	466b      	mov	r3, sp
    33e6:	1d98      	adds	r0, r3, #6
    33e8:	4b8c      	ldr	r3, [pc, #560]	; (361c <usb_handle_standard_request+0x308>)
    33ea:	681b      	ldr	r3, [r3, #0]
    33ec:	7003      	strb	r3, [r0, #0]
      udc_control_send(&config, sizeof(config));
    33ee:	2101      	movs	r1, #1
    33f0:	4b88      	ldr	r3, [pc, #544]	; (3614 <usb_handle_standard_request+0x300>)
    33f2:	4798      	blx	r3
    } break;
    33f4:	e073      	b.n	34de <usb_handle_standard_request+0x1ca>
      uint8_t type = request->wValue >> 8;
    33f6:	7882      	ldrb	r2, [r0, #2]
    33f8:	78c3      	ldrb	r3, [r0, #3]
    33fa:	021b      	lsls	r3, r3, #8
    33fc:	4313      	orrs	r3, r2
    33fe:	0a1a      	lsrs	r2, r3, #8
      uint16_t length = request->wLength;
    3400:	7981      	ldrb	r1, [r0, #6]
    3402:	79c6      	ldrb	r6, [r0, #7]
    3404:	0236      	lsls	r6, r6, #8
    3406:	430e      	orrs	r6, r1
      if (USB_DEVICE_DESCRIPTOR == type)
    3408:	2a01      	cmp	r2, #1
    340a:	d033      	beq.n	3474 <usb_handle_standard_request+0x160>
      else if (USB_CONFIGURATION_DESCRIPTOR == type)
    340c:	2a02      	cmp	r2, #2
    340e:	d03d      	beq.n	348c <usb_handle_standard_request+0x178>
      else if (USB_STRING_DESCRIPTOR == type)
    3410:	2a03      	cmp	r2, #3
    3412:	d159      	bne.n	34c8 <usb_handle_standard_request+0x1b4>
      uint8_t index = request->wValue & 0xff;
    3414:	b2db      	uxtb	r3, r3
        if (0 == index)
    3416:	2b00      	cmp	r3, #0
    3418:	d047      	beq.n	34aa <usb_handle_standard_request+0x196>
        else if (index < USB_STR_COUNT)
    341a:	2b04      	cmp	r3, #4
    341c:	d851      	bhi.n	34c2 <usb_handle_standard_request+0x1ae>
          const char *str = usb_strings[index];
    341e:	009b      	lsls	r3, r3, #2
    3420:	4a7f      	ldr	r2, [pc, #508]	; (3620 <usb_handle_standard_request+0x30c>)
    3422:	589c      	ldr	r4, [r3, r2]
          int len = strlen(str);
    3424:	0020      	movs	r0, r4
    3426:	4b7f      	ldr	r3, [pc, #508]	; (3624 <usb_handle_standard_request+0x310>)
    3428:	4798      	blx	r3
    342a:	0005      	movs	r5, r0
          memset(usb_string_descriptor_buffer, 0, sizeof(usb_string_descriptor_buffer));
    342c:	4f7e      	ldr	r7, [pc, #504]	; (3628 <usb_handle_standard_request+0x314>)
    342e:	2240      	movs	r2, #64	; 0x40
    3430:	2100      	movs	r1, #0
    3432:	0038      	movs	r0, r7
    3434:	4b7d      	ldr	r3, [pc, #500]	; (362c <usb_handle_standard_request+0x318>)
    3436:	4798      	blx	r3
          usb_string_descriptor_buffer[0] = len*2 + 2;
    3438:	1c6b      	adds	r3, r5, #1
    343a:	005b      	lsls	r3, r3, #1
    343c:	703b      	strb	r3, [r7, #0]
          usb_string_descriptor_buffer[1] = USB_STRING_DESCRIPTOR;
    343e:	2303      	movs	r3, #3
    3440:	707b      	strb	r3, [r7, #1]
          for (int i = 0; i < len; i++)
    3442:	2d00      	cmp	r5, #0
    3444:	dd0a      	ble.n	345c <usb_handle_standard_request+0x148>
    3446:	4b7a      	ldr	r3, [pc, #488]	; (3630 <usb_handle_standard_request+0x31c>)
    3448:	1c68      	adds	r0, r5, #1
    344a:	0040      	lsls	r0, r0, #1
    344c:	1e99      	subs	r1, r3, #2
    344e:	1840      	adds	r0, r0, r1
            usb_string_descriptor_buffer[2 + i*2] = str[i];
    3450:	7821      	ldrb	r1, [r4, #0]
    3452:	7019      	strb	r1, [r3, #0]
    3454:	3401      	adds	r4, #1
    3456:	3302      	adds	r3, #2
          for (int i = 0; i < len; i++)
    3458:	4283      	cmp	r3, r0
    345a:	d1f9      	bne.n	3450 <usb_handle_standard_request+0x13c>
          length = LIMIT(length, usb_string_descriptor_buffer[0]);
    345c:	4b72      	ldr	r3, [pc, #456]	; (3628 <usb_handle_standard_request+0x314>)
    345e:	781b      	ldrb	r3, [r3, #0]
    3460:	1c19      	adds	r1, r3, #0
    3462:	b29b      	uxth	r3, r3
    3464:	42b3      	cmp	r3, r6
    3466:	d900      	bls.n	346a <usb_handle_standard_request+0x156>
    3468:	1c31      	adds	r1, r6, #0
          udc_control_send(usb_string_descriptor_buffer, length);
    346a:	b289      	uxth	r1, r1
    346c:	486e      	ldr	r0, [pc, #440]	; (3628 <usb_handle_standard_request+0x314>)
    346e:	4b69      	ldr	r3, [pc, #420]	; (3614 <usb_handle_standard_request+0x300>)
    3470:	4798      	blx	r3
    3472:	e034      	b.n	34de <usb_handle_standard_request+0x1ca>
        length = LIMIT(length, usb_device_descriptor.bLength);
    3474:	4b6f      	ldr	r3, [pc, #444]	; (3634 <usb_handle_standard_request+0x320>)
    3476:	781b      	ldrb	r3, [r3, #0]
    3478:	1c19      	adds	r1, r3, #0
    347a:	b29b      	uxth	r3, r3
    347c:	42b3      	cmp	r3, r6
    347e:	d900      	bls.n	3482 <usb_handle_standard_request+0x16e>
    3480:	1c31      	adds	r1, r6, #0
        udc_control_send((uint8_t *)&usb_device_descriptor, length);
    3482:	b289      	uxth	r1, r1
    3484:	486b      	ldr	r0, [pc, #428]	; (3634 <usb_handle_standard_request+0x320>)
    3486:	4b63      	ldr	r3, [pc, #396]	; (3614 <usb_handle_standard_request+0x300>)
    3488:	4798      	blx	r3
    348a:	e028      	b.n	34de <usb_handle_standard_request+0x1ca>
        length = LIMIT(length, usb_configuration_hierarchy.configuration.wTotalLength);
    348c:	4a6a      	ldr	r2, [pc, #424]	; (3638 <usb_handle_standard_request+0x324>)
    348e:	7891      	ldrb	r1, [r2, #2]
    3490:	78d3      	ldrb	r3, [r2, #3]
    3492:	021b      	lsls	r3, r3, #8
    3494:	430b      	orrs	r3, r1
    3496:	1c19      	adds	r1, r3, #0
    3498:	b29b      	uxth	r3, r3
    349a:	42b3      	cmp	r3, r6
    349c:	d900      	bls.n	34a0 <usb_handle_standard_request+0x18c>
    349e:	1c31      	adds	r1, r6, #0
        udc_control_send((uint8_t *)&usb_configuration_hierarchy, length);
    34a0:	b289      	uxth	r1, r1
    34a2:	4865      	ldr	r0, [pc, #404]	; (3638 <usb_handle_standard_request+0x324>)
    34a4:	4b5b      	ldr	r3, [pc, #364]	; (3614 <usb_handle_standard_request+0x300>)
    34a6:	4798      	blx	r3
    34a8:	e019      	b.n	34de <usb_handle_standard_request+0x1ca>
          length = LIMIT(length, usb_string_descriptor_zero.bLength);
    34aa:	4b64      	ldr	r3, [pc, #400]	; (363c <usb_handle_standard_request+0x328>)
    34ac:	781b      	ldrb	r3, [r3, #0]
    34ae:	1c19      	adds	r1, r3, #0
    34b0:	b29b      	uxth	r3, r3
    34b2:	42b3      	cmp	r3, r6
    34b4:	d900      	bls.n	34b8 <usb_handle_standard_request+0x1a4>
    34b6:	1c31      	adds	r1, r6, #0
          udc_control_send((uint8_t *)&usb_string_descriptor_zero, length);
    34b8:	b289      	uxth	r1, r1
    34ba:	4860      	ldr	r0, [pc, #384]	; (363c <usb_handle_standard_request+0x328>)
    34bc:	4b55      	ldr	r3, [pc, #340]	; (3614 <usb_handle_standard_request+0x300>)
    34be:	4798      	blx	r3
    34c0:	e00d      	b.n	34de <usb_handle_standard_request+0x1ca>
          udc_control_stall();
    34c2:	4b51      	ldr	r3, [pc, #324]	; (3608 <usb_handle_standard_request+0x2f4>)
    34c4:	4798      	blx	r3
    34c6:	e00a      	b.n	34de <usb_handle_standard_request+0x1ca>
        udc_control_stall();
    34c8:	4b4f      	ldr	r3, [pc, #316]	; (3608 <usb_handle_standard_request+0x2f4>)
    34ca:	4798      	blx	r3
    34cc:	e007      	b.n	34de <usb_handle_standard_request+0x1ca>
      udc_control_send_zlp();
    34ce:	4b5c      	ldr	r3, [pc, #368]	; (3640 <usb_handle_standard_request+0x32c>)
    34d0:	4798      	blx	r3
      udc_set_address(request->wValue);
    34d2:	78a3      	ldrb	r3, [r4, #2]
    34d4:	78e0      	ldrb	r0, [r4, #3]
    34d6:	0200      	lsls	r0, r0, #8
    34d8:	4318      	orrs	r0, r3
    34da:	4b5a      	ldr	r3, [pc, #360]	; (3644 <usb_handle_standard_request+0x330>)
    34dc:	4798      	blx	r3
}
    34de:	b002      	add	sp, #8
    34e0:	bc04      	pop	{r2}
    34e2:	4690      	mov	r8, r2
    34e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (request->wIndex == USB_KEYBOARD_INTERFACE)
    34e6:	7902      	ldrb	r2, [r0, #4]
    34e8:	7943      	ldrb	r3, [r0, #5]
    34ea:	021b      	lsls	r3, r3, #8
    34ec:	4313      	orrs	r3, r2
    34ee:	2b01      	cmp	r3, #1
    34f0:	d1f5      	bne.n	34de <usb_handle_standard_request+0x1ca>
            USB->DEVICE.DeviceEndpoint[0].EPSTATUSCLR.bit.BK0RDY = 1;
    34f2:	4955      	ldr	r1, [pc, #340]	; (3648 <usb_handle_standard_request+0x334>)
    34f4:	2282      	movs	r2, #130	; 0x82
    34f6:	0052      	lsls	r2, r2, #1
    34f8:	5c8b      	ldrb	r3, [r1, r2]
    34fa:	2040      	movs	r0, #64	; 0x40
    34fc:	4303      	orrs	r3, r0
    34fe:	548b      	strb	r3, [r1, r2]
            while ((USB->DEVICE.DeviceEndpoint[0].EPINTFLAG.bit.TRCPT0) == 0);
    3500:	2208      	movs	r2, #8
    3502:	32ff      	adds	r2, #255	; 0xff
    3504:	5c8b      	ldrb	r3, [r1, r2]
    3506:	07db      	lsls	r3, r3, #31
    3508:	d5fc      	bpl.n	3504 <usb_handle_standard_request+0x1f0>
            udc_control_send_zlp();
    350a:	4b4d      	ldr	r3, [pc, #308]	; (3640 <usb_handle_standard_request+0x32c>)
    350c:	4798      	blx	r3
    350e:	e7e6      	b.n	34de <usb_handle_standard_request+0x1ca>
      usb_config = request->wValue;
    3510:	4d42      	ldr	r5, [pc, #264]	; (361c <usb_handle_standard_request+0x308>)
    3512:	7882      	ldrb	r2, [r0, #2]
    3514:	78c3      	ldrb	r3, [r0, #3]
    3516:	021b      	lsls	r3, r3, #8
    3518:	4313      	orrs	r3, r2
    351a:	602b      	str	r3, [r5, #0]
      udc_control_send_zlp();
    351c:	4b48      	ldr	r3, [pc, #288]	; (3640 <usb_handle_standard_request+0x32c>)
    351e:	4798      	blx	r3
      if (usb_config)
    3520:	682b      	ldr	r3, [r5, #0]
    3522:	2b00      	cmp	r3, #0
    3524:	d0db      	beq.n	34de <usb_handle_standard_request+0x1ca>
        int size = usb_configuration_hierarchy.configuration.wTotalLength;
    3526:	4b44      	ldr	r3, [pc, #272]	; (3638 <usb_handle_standard_request+0x324>)
    3528:	789a      	ldrb	r2, [r3, #2]
    352a:	78dd      	ldrb	r5, [r3, #3]
    352c:	022d      	lsls	r5, r5, #8
    352e:	4315      	orrs	r5, r2
        while (size)
    3530:	d00d      	beq.n	354e <usb_handle_standard_request+0x23a>
    3532:	001c      	movs	r4, r3
    3534:	e004      	b.n	3540 <usb_handle_standard_request+0x22c>
          size -= desc->bLength;
    3536:	7823      	ldrb	r3, [r4, #0]
    3538:	1aed      	subs	r5, r5, r3
          desc = (usb_descriptor_header_t *)((uint8_t *)desc + desc->bLength);
    353a:	18e4      	adds	r4, r4, r3
        while (size)
    353c:	2d00      	cmp	r5, #0
    353e:	d006      	beq.n	354e <usb_handle_standard_request+0x23a>
          if (USB_ENDPOINT_DESCRIPTOR == desc->bDescriptorType)
    3540:	7863      	ldrb	r3, [r4, #1]
    3542:	2b05      	cmp	r3, #5
    3544:	d1f7      	bne.n	3536 <usb_handle_standard_request+0x222>
            udc_configure_endpoint((usb_endpoint_descriptor_t *)desc);
    3546:	0020      	movs	r0, r4
    3548:	4b40      	ldr	r3, [pc, #256]	; (364c <usb_handle_standard_request+0x338>)
    354a:	4798      	blx	r3
    354c:	e7f3      	b.n	3536 <usb_handle_standard_request+0x222>
        comms_usb_configuration_callback(usb_config);
    354e:	4b33      	ldr	r3, [pc, #204]	; (361c <usb_handle_standard_request+0x308>)
    3550:	6818      	ldr	r0, [r3, #0]
    3552:	4b3f      	ldr	r3, [pc, #252]	; (3650 <usb_handle_standard_request+0x33c>)
    3554:	4798      	blx	r3
    3556:	e7c2      	b.n	34de <usb_handle_standard_request+0x1ca>
      uint16_t status = 0;
    3558:	466b      	mov	r3, sp
    355a:	1d98      	adds	r0, r3, #6
    355c:	2300      	movs	r3, #0
    355e:	8003      	strh	r3, [r0, #0]
      udc_control_send((uint8_t *)&status, sizeof(status));
    3560:	2102      	movs	r1, #2
    3562:	4b2c      	ldr	r3, [pc, #176]	; (3614 <usb_handle_standard_request+0x300>)
    3564:	4798      	blx	r3
    } break;
    3566:	e7ba      	b.n	34de <usb_handle_standard_request+0x1ca>
        udc_control_stall();
    3568:	4b27      	ldr	r3, [pc, #156]	; (3608 <usb_handle_standard_request+0x2f4>)
    356a:	4798      	blx	r3
    } break;
    356c:	e7b7      	b.n	34de <usb_handle_standard_request+0x1ca>
      udc_control_send_zlp();
    356e:	4b34      	ldr	r3, [pc, #208]	; (3640 <usb_handle_standard_request+0x32c>)
    3570:	4798      	blx	r3
    } break;
    3572:	e7b4      	b.n	34de <usb_handle_standard_request+0x1ca>
      int ep = request->wIndex & USB_INDEX_MASK;
    3574:	7902      	ldrb	r2, [r0, #4]
    3576:	7943      	ldrb	r3, [r0, #5]
    3578:	021b      	lsls	r3, r3, #8
    357a:	4313      	orrs	r3, r2
    357c:	257f      	movs	r5, #127	; 0x7f
    357e:	401d      	ands	r5, r3
      if (0 == request->wValue && ep && udc_endpoint_configured(ep, dir))
    3580:	7881      	ldrb	r1, [r0, #2]
    3582:	78c2      	ldrb	r2, [r0, #3]
    3584:	0212      	lsls	r2, r2, #8
    3586:	430a      	orrs	r2, r1
    3588:	d101      	bne.n	358e <usb_handle_standard_request+0x27a>
    358a:	2d00      	cmp	r5, #0
    358c:	d102      	bne.n	3594 <usb_handle_standard_request+0x280>
        udc_control_stall();
    358e:	4b1e      	ldr	r3, [pc, #120]	; (3608 <usb_handle_standard_request+0x2f4>)
    3590:	4798      	blx	r3
    3592:	e7a4      	b.n	34de <usb_handle_standard_request+0x1ca>
      int dir = request->wIndex & USB_DIRECTION_MASK;
    3594:	2480      	movs	r4, #128	; 0x80
    3596:	401c      	ands	r4, r3
      if (0 == request->wValue && ep && udc_endpoint_configured(ep, dir))
    3598:	0021      	movs	r1, r4
    359a:	0028      	movs	r0, r5
    359c:	4b1b      	ldr	r3, [pc, #108]	; (360c <usb_handle_standard_request+0x2f8>)
    359e:	4798      	blx	r3
    35a0:	2800      	cmp	r0, #0
    35a2:	d0f4      	beq.n	358e <usb_handle_standard_request+0x27a>
        udc_endpoint_set_feature(ep, dir);
    35a4:	0021      	movs	r1, r4
    35a6:	0028      	movs	r0, r5
    35a8:	4b2a      	ldr	r3, [pc, #168]	; (3654 <usb_handle_standard_request+0x340>)
    35aa:	4798      	blx	r3
        udc_control_send_zlp();
    35ac:	4b24      	ldr	r3, [pc, #144]	; (3640 <usb_handle_standard_request+0x32c>)
    35ae:	4798      	blx	r3
    35b0:	e795      	b.n	34de <usb_handle_standard_request+0x1ca>
      udc_control_stall();
    35b2:	4b15      	ldr	r3, [pc, #84]	; (3608 <usb_handle_standard_request+0x2f4>)
    35b4:	4798      	blx	r3
    } break;
    35b6:	e792      	b.n	34de <usb_handle_standard_request+0x1ca>
      udc_control_send_zlp();
    35b8:	4b21      	ldr	r3, [pc, #132]	; (3640 <usb_handle_standard_request+0x32c>)
    35ba:	4798      	blx	r3
    } break;
    35bc:	e78f      	b.n	34de <usb_handle_standard_request+0x1ca>
      int ep = request->wIndex & USB_INDEX_MASK;
    35be:	7902      	ldrb	r2, [r0, #4]
    35c0:	7943      	ldrb	r3, [r0, #5]
    35c2:	021b      	lsls	r3, r3, #8
    35c4:	4313      	orrs	r3, r2
    35c6:	257f      	movs	r5, #127	; 0x7f
    35c8:	401d      	ands	r5, r3
      if (0 == request->wValue && ep && udc_endpoint_configured(ep, dir))
    35ca:	7881      	ldrb	r1, [r0, #2]
    35cc:	78c2      	ldrb	r2, [r0, #3]
    35ce:	0212      	lsls	r2, r2, #8
    35d0:	430a      	orrs	r2, r1
    35d2:	d101      	bne.n	35d8 <usb_handle_standard_request+0x2c4>
    35d4:	2d00      	cmp	r5, #0
    35d6:	d102      	bne.n	35de <usb_handle_standard_request+0x2ca>
        udc_control_stall();
    35d8:	4b0b      	ldr	r3, [pc, #44]	; (3608 <usb_handle_standard_request+0x2f4>)
    35da:	4798      	blx	r3
    35dc:	e77f      	b.n	34de <usb_handle_standard_request+0x1ca>
      int dir = request->wIndex & USB_DIRECTION_MASK;
    35de:	2480      	movs	r4, #128	; 0x80
    35e0:	401c      	ands	r4, r3
      if (0 == request->wValue && ep && udc_endpoint_configured(ep, dir))
    35e2:	0021      	movs	r1, r4
    35e4:	0028      	movs	r0, r5
    35e6:	4b09      	ldr	r3, [pc, #36]	; (360c <usb_handle_standard_request+0x2f8>)
    35e8:	4798      	blx	r3
    35ea:	2800      	cmp	r0, #0
    35ec:	d0f4      	beq.n	35d8 <usb_handle_standard_request+0x2c4>
        udc_endpoint_clear_feature(ep, dir);
    35ee:	0021      	movs	r1, r4
    35f0:	0028      	movs	r0, r5
    35f2:	4b19      	ldr	r3, [pc, #100]	; (3658 <usb_handle_standard_request+0x344>)
    35f4:	4798      	blx	r3
        udc_control_send_zlp();
    35f6:	4b12      	ldr	r3, [pc, #72]	; (3640 <usb_handle_standard_request+0x32c>)
    35f8:	4798      	blx	r3
    35fa:	e770      	b.n	34de <usb_handle_standard_request+0x1ca>
    35fc:	00000301 	.word	0x00000301
    3600:	00000681 	.word	0x00000681
    3604:	00000302 	.word	0x00000302
    3608:	000030a9 	.word	0x000030a9
    360c:	00002ee9 	.word	0x00002ee9
    3610:	00002f19 	.word	0x00002f19
    3614:	000030bd 	.word	0x000030bd
    3618:	00000921 	.word	0x00000921
    361c:	20000334 	.word	0x20000334
    3620:	200000bc 	.word	0x200000bc
    3624:	00003a0f 	.word	0x00003a0f
    3628:	20001104 	.word	0x20001104
    362c:	000039ff 	.word	0x000039ff
    3630:	20001106 	.word	0x20001106
    3634:	20000088 	.word	0x20000088
    3638:	20000044 	.word	0x20000044
    363c:	200000b8 	.word	0x200000b8
    3640:	00003071 	.word	0x00003071
    3644:	00002fd9 	.word	0x00002fd9
    3648:	41005000 	.word	0x41005000
    364c:	00002da5 	.word	0x00002da5
    3650:	000024fd 	.word	0x000024fd
    3654:	00002f41 	.word	0x00002f41
    3658:	00002f6d 	.word	0x00002f6d
      uint16_t length = request->wLength;
    365c:	7982      	ldrb	r2, [r0, #6]
    365e:	79c3      	ldrb	r3, [r0, #7]
    3660:	021b      	lsls	r3, r3, #8
    3662:	4313      	orrs	r3, r2
      if (request->wIndex == USB_RAWHID_INTERFACE)
    3664:	7901      	ldrb	r1, [r0, #4]
    3666:	7942      	ldrb	r2, [r0, #5]
    3668:	0212      	lsls	r2, r2, #8
    366a:	430a      	orrs	r2, r1
    366c:	d108      	bne.n	3680 <usb_handle_standard_request+0x36c>
          length = LIMIT(length, sizeof(usb_hid_report_descriptor));
    366e:	1c19      	adds	r1, r3, #0
    3670:	2b1c      	cmp	r3, #28
    3672:	d900      	bls.n	3676 <usb_handle_standard_request+0x362>
    3674:	211c      	movs	r1, #28
          udc_control_send(usb_hid_report_descriptor, length);
    3676:	b289      	uxth	r1, r1
    3678:	4806      	ldr	r0, [pc, #24]	; (3694 <usb_handle_standard_request+0x380>)
    367a:	4b07      	ldr	r3, [pc, #28]	; (3698 <usb_handle_standard_request+0x384>)
    367c:	4798      	blx	r3
    367e:	e72e      	b.n	34de <usb_handle_standard_request+0x1ca>
          length = LIMIT(length, sizeof(keyboard_hid_report_desc));
    3680:	1c19      	adds	r1, r3, #0
    3682:	2b3f      	cmp	r3, #63	; 0x3f
    3684:	d900      	bls.n	3688 <usb_handle_standard_request+0x374>
    3686:	213f      	movs	r1, #63	; 0x3f
          udc_control_send(keyboard_hid_report_desc, length);
    3688:	b289      	uxth	r1, r1
    368a:	4804      	ldr	r0, [pc, #16]	; (369c <usb_handle_standard_request+0x388>)
    368c:	4b02      	ldr	r3, [pc, #8]	; (3698 <usb_handle_standard_request+0x384>)
    368e:	4798      	blx	r3
    3690:	e725      	b.n	34de <usb_handle_standard_request+0x1ca>
    3692:	46c0      	nop			; (mov r8, r8)
    3694:	2000009c 	.word	0x2000009c
    3698:	000030bd 	.word	0x000030bd
    369c:	20000004 	.word	0x20000004

000036a0 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    36a0:	4b0c      	ldr	r3, [pc, #48]	; (36d4 <cpu_irq_enter_critical+0x34>)
    36a2:	681b      	ldr	r3, [r3, #0]
    36a4:	2b00      	cmp	r3, #0
    36a6:	d106      	bne.n	36b6 <cpu_irq_enter_critical+0x16>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    36a8:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    36ac:	2b00      	cmp	r3, #0
    36ae:	d007      	beq.n	36c0 <cpu_irq_enter_critical+0x20>
			cpu_irq_disable();
			cpu_irq_prev_interrupt_state = true;
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    36b0:	2200      	movs	r2, #0
    36b2:	4b09      	ldr	r3, [pc, #36]	; (36d8 <cpu_irq_enter_critical+0x38>)
    36b4:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    36b6:	4a07      	ldr	r2, [pc, #28]	; (36d4 <cpu_irq_enter_critical+0x34>)
    36b8:	6813      	ldr	r3, [r2, #0]
    36ba:	3301      	adds	r3, #1
    36bc:	6013      	str	r3, [r2, #0]
}
    36be:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
    36c0:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    36c2:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    36c6:	2200      	movs	r2, #0
    36c8:	4b04      	ldr	r3, [pc, #16]	; (36dc <cpu_irq_enter_critical+0x3c>)
    36ca:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    36cc:	3201      	adds	r2, #1
    36ce:	4b02      	ldr	r3, [pc, #8]	; (36d8 <cpu_irq_enter_critical+0x38>)
    36d0:	701a      	strb	r2, [r3, #0]
    36d2:	e7f0      	b.n	36b6 <cpu_irq_enter_critical+0x16>
    36d4:	20000338 	.word	0x20000338
    36d8:	2000033c 	.word	0x2000033c
    36dc:	200000d0 	.word	0x200000d0

000036e0 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    36e0:	4b08      	ldr	r3, [pc, #32]	; (3704 <cpu_irq_leave_critical+0x24>)
    36e2:	681a      	ldr	r2, [r3, #0]
    36e4:	3a01      	subs	r2, #1
    36e6:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    36e8:	681b      	ldr	r3, [r3, #0]
    36ea:	2b00      	cmp	r3, #0
    36ec:	d109      	bne.n	3702 <cpu_irq_leave_critical+0x22>
    36ee:	4b06      	ldr	r3, [pc, #24]	; (3708 <cpu_irq_leave_critical+0x28>)
    36f0:	781b      	ldrb	r3, [r3, #0]
    36f2:	2b00      	cmp	r3, #0
    36f4:	d005      	beq.n	3702 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    36f6:	2201      	movs	r2, #1
    36f8:	4b04      	ldr	r3, [pc, #16]	; (370c <cpu_irq_leave_critical+0x2c>)
    36fa:	701a      	strb	r2, [r3, #0]
    36fc:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    3700:	b662      	cpsie	i
	}
}
    3702:	4770      	bx	lr
    3704:	20000338 	.word	0x20000338
    3708:	2000033c 	.word	0x2000033c
    370c:	200000d0 	.word	0x200000d0

00003710 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    3710:	e7fe      	b.n	3710 <Dummy_Handler>
	...

00003714 <Reset_Handler>:
{
    3714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
    3716:	4a2a      	ldr	r2, [pc, #168]	; (37c0 <Reset_Handler+0xac>)
    3718:	4b2a      	ldr	r3, [pc, #168]	; (37c4 <Reset_Handler+0xb0>)
    371a:	429a      	cmp	r2, r3
    371c:	d011      	beq.n	3742 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
    371e:	001a      	movs	r2, r3
    3720:	4b29      	ldr	r3, [pc, #164]	; (37c8 <Reset_Handler+0xb4>)
    3722:	429a      	cmp	r2, r3
    3724:	d20d      	bcs.n	3742 <Reset_Handler+0x2e>
    3726:	4a29      	ldr	r2, [pc, #164]	; (37cc <Reset_Handler+0xb8>)
    3728:	3303      	adds	r3, #3
    372a:	1a9b      	subs	r3, r3, r2
    372c:	089b      	lsrs	r3, r3, #2
    372e:	3301      	adds	r3, #1
    3730:	009b      	lsls	r3, r3, #2
    3732:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    3734:	4823      	ldr	r0, [pc, #140]	; (37c4 <Reset_Handler+0xb0>)
    3736:	4922      	ldr	r1, [pc, #136]	; (37c0 <Reset_Handler+0xac>)
    3738:	588c      	ldr	r4, [r1, r2]
    373a:	5084      	str	r4, [r0, r2]
    373c:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    373e:	429a      	cmp	r2, r3
    3740:	d1fa      	bne.n	3738 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
    3742:	4a23      	ldr	r2, [pc, #140]	; (37d0 <Reset_Handler+0xbc>)
    3744:	4b23      	ldr	r3, [pc, #140]	; (37d4 <Reset_Handler+0xc0>)
    3746:	429a      	cmp	r2, r3
    3748:	d20a      	bcs.n	3760 <Reset_Handler+0x4c>
    374a:	43d3      	mvns	r3, r2
    374c:	4921      	ldr	r1, [pc, #132]	; (37d4 <Reset_Handler+0xc0>)
    374e:	185b      	adds	r3, r3, r1
    3750:	2103      	movs	r1, #3
    3752:	438b      	bics	r3, r1
    3754:	3304      	adds	r3, #4
    3756:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
    3758:	2100      	movs	r1, #0
    375a:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
    375c:	4293      	cmp	r3, r2
    375e:	d1fc      	bne.n	375a <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    3760:	4a1d      	ldr	r2, [pc, #116]	; (37d8 <Reset_Handler+0xc4>)
    3762:	21ff      	movs	r1, #255	; 0xff
    3764:	4b1d      	ldr	r3, [pc, #116]	; (37dc <Reset_Handler+0xc8>)
    3766:	438b      	bics	r3, r1
    3768:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    376a:	39fd      	subs	r1, #253	; 0xfd
    376c:	2390      	movs	r3, #144	; 0x90
    376e:	005b      	lsls	r3, r3, #1
    3770:	4a1b      	ldr	r2, [pc, #108]	; (37e0 <Reset_Handler+0xcc>)
    3772:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    3774:	4a1b      	ldr	r2, [pc, #108]	; (37e4 <Reset_Handler+0xd0>)
    3776:	78d3      	ldrb	r3, [r2, #3]
    3778:	2503      	movs	r5, #3
    377a:	43ab      	bics	r3, r5
    377c:	2402      	movs	r4, #2
    377e:	4323      	orrs	r3, r4
    3780:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    3782:	78d3      	ldrb	r3, [r2, #3]
    3784:	270c      	movs	r7, #12
    3786:	43bb      	bics	r3, r7
    3788:	2608      	movs	r6, #8
    378a:	4333      	orrs	r3, r6
    378c:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    378e:	4b16      	ldr	r3, [pc, #88]	; (37e8 <Reset_Handler+0xd4>)
    3790:	7b98      	ldrb	r0, [r3, #14]
    3792:	2230      	movs	r2, #48	; 0x30
    3794:	4390      	bics	r0, r2
    3796:	2220      	movs	r2, #32
    3798:	4310      	orrs	r0, r2
    379a:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    379c:	7b99      	ldrb	r1, [r3, #14]
    379e:	43b9      	bics	r1, r7
    37a0:	4331      	orrs	r1, r6
    37a2:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    37a4:	7b9a      	ldrb	r2, [r3, #14]
    37a6:	43aa      	bics	r2, r5
    37a8:	4322      	orrs	r2, r4
    37aa:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    37ac:	4a0f      	ldr	r2, [pc, #60]	; (37ec <Reset_Handler+0xd8>)
    37ae:	6853      	ldr	r3, [r2, #4]
    37b0:	2180      	movs	r1, #128	; 0x80
    37b2:	430b      	orrs	r3, r1
    37b4:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    37b6:	4b0e      	ldr	r3, [pc, #56]	; (37f0 <Reset_Handler+0xdc>)
    37b8:	4798      	blx	r3
        main();
    37ba:	4b0e      	ldr	r3, [pc, #56]	; (37f4 <Reset_Handler+0xe0>)
    37bc:	4798      	blx	r3
    37be:	e7fe      	b.n	37be <Reset_Handler+0xaa>
    37c0:	00003a7c 	.word	0x00003a7c
    37c4:	20000000 	.word	0x20000000
    37c8:	200000d4 	.word	0x200000d4
    37cc:	20000004 	.word	0x20000004
    37d0:	200000e0 	.word	0x200000e0
    37d4:	20001144 	.word	0x20001144
    37d8:	e000ed00 	.word	0xe000ed00
    37dc:	00002000 	.word	0x00002000
    37e0:	41007000 	.word	0x41007000
    37e4:	41005000 	.word	0x41005000
    37e8:	41004800 	.word	0x41004800
    37ec:	41004000 	.word	0x41004000
    37f0:	000039a5 	.word	0x000039a5
    37f4:	00003871 	.word	0x00003871

000037f8 <main_platform_init>:

/*! \fn     main_platform_init(void)
*   \brief  Initialize our platform
*/
void main_platform_init(void)
{
    37f8:	b510      	push	{r4, lr}
    /* Initialization results vars */
    RET_TYPE fuses_ok;
    
    /* Check fuses */
    fuses_ok = fuses_check_program(TRUE);                               // Check fuses and program them if incorrectly set
    37fa:	2001      	movs	r0, #1
    37fc:	4b08      	ldr	r3, [pc, #32]	; (3820 <main_platform_init+0x28>)
    37fe:	4798      	blx	r3
    while(fuses_ok == RETURN_NOK);
    3800:	1c43      	adds	r3, r0, #1
    3802:	d100      	bne.n	3806 <main_platform_init+0xe>
    3804:	e7fe      	b.n	3804 <main_platform_init+0xc>
    
    /* Perform Initializations */
    clocks_start_48MDFLL();                                             // Switch to 48M main clock
    3806:	4b07      	ldr	r3, [pc, #28]	; (3824 <main_platform_init+0x2c>)
    3808:	4798      	blx	r3
    dma_init();                                                         // Initialize the DMA controller
    380a:	4b07      	ldr	r3, [pc, #28]	; (3828 <main_platform_init+0x30>)
    380c:	4798      	blx	r3
    timer_initialize_timebase();                                        // Initialize the platform time base
    380e:	4b07      	ldr	r3, [pc, #28]	; (382c <main_platform_init+0x34>)
    3810:	4798      	blx	r3
    platform_io_init_ports();                                           // Initialize platform IO ports
    3812:	4b07      	ldr	r3, [pc, #28]	; (3830 <main_platform_init+0x38>)
    3814:	4798      	blx	r3
    comms_main_init_rx();                                               // Initialize communication handling with main MCU    
    3816:	4b07      	ldr	r3, [pc, #28]	; (3834 <main_platform_init+0x3c>)
    3818:	4798      	blx	r3
    usb_init();                                                         // Initialize USB stack
    381a:	4b07      	ldr	r3, [pc, #28]	; (3838 <main_platform_init+0x40>)
    381c:	4798      	blx	r3
}    
    381e:	bd10      	pop	{r4, pc}
    3820:	00002a61 	.word	0x00002a61
    3824:	0000213d 	.word	0x0000213d
    3828:	000026a5 	.word	0x000026a5
    382c:	00002b39 	.word	0x00002b39
    3830:	00002a35 	.word	0x00002a35
    3834:	000021f1 	.word	0x000021f1
    3838:	000032e5 	.word	0x000032e5

0000383c <main_standby_sleep>:

/*! \fn     main_standby_sleep(void)
*   \brief  Go to sleep
*/
void main_standby_sleep(void)
{        
    383c:	b510      	push	{r4, lr}
    /* Errata 10416: disable interrupt routines */
    cpu_irq_enter_critical();
    383e:	4b07      	ldr	r3, [pc, #28]	; (385c <main_standby_sleep+0x20>)
    3840:	4798      	blx	r3
        
    /* Prepare the ports for sleep */
    platform_io_prepare_ports_for_sleep();
    3842:	4b07      	ldr	r3, [pc, #28]	; (3860 <main_standby_sleep+0x24>)
    3844:	4798      	blx	r3
    
    /* Enter deep sleep */
    SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
    3846:	2204      	movs	r2, #4
    3848:	4b06      	ldr	r3, [pc, #24]	; (3864 <main_standby_sleep+0x28>)
    384a:	611a      	str	r2, [r3, #16]
  __ASM volatile ("dsb");
    384c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("wfi");
    3850:	bf30      	wfi
    __DSB();
    __WFI();
    
    /* Prepare ports for sleep exit */
    platform_io_prepare_ports_for_sleep_exit();
    3852:	4b05      	ldr	r3, [pc, #20]	; (3868 <main_standby_sleep+0x2c>)
    3854:	4798      	blx	r3
    
    /* Damn errata... enable interrupts */
    cpu_irq_leave_critical();    
    3856:	4b05      	ldr	r3, [pc, #20]	; (386c <main_standby_sleep+0x30>)
    3858:	4798      	blx	r3
}
    385a:	bd10      	pop	{r4, pc}
    385c:	000036a1 	.word	0x000036a1
    3860:	00002a49 	.word	0x00002a49
    3864:	e000ed00 	.word	0xe000ed00
    3868:	00002a55 	.word	0x00002a55
    386c:	000036e1 	.word	0x000036e1

00003870 <main>:

int main (void)
{
    3870:	b570      	push	{r4, r5, r6, lr}
    /* Initialize our platform */
    main_platform_init();
    3872:	4b03      	ldr	r3, [pc, #12]	; (3880 <main+0x10>)
    3874:	4798      	blx	r3
    
    while(1)
    {
        comms_main_mcu_routine();
    3876:	4d03      	ldr	r5, [pc, #12]	; (3884 <main+0x14>)
        comms_usb_communication_routine();
    3878:	4c03      	ldr	r4, [pc, #12]	; (3888 <main+0x18>)
        comms_main_mcu_routine();
    387a:	47a8      	blx	r5
        comms_usb_communication_routine();
    387c:	47a0      	blx	r4
    387e:	e7fc      	b.n	387a <main+0xa>
    3880:	000037f9 	.word	0x000037f9
    3884:	000022a5 	.word	0x000022a5
    3888:	00002525 	.word	0x00002525

0000388c <__udivsi3>:
    388c:	2200      	movs	r2, #0
    388e:	0843      	lsrs	r3, r0, #1
    3890:	428b      	cmp	r3, r1
    3892:	d374      	bcc.n	397e <__udivsi3+0xf2>
    3894:	0903      	lsrs	r3, r0, #4
    3896:	428b      	cmp	r3, r1
    3898:	d35f      	bcc.n	395a <__udivsi3+0xce>
    389a:	0a03      	lsrs	r3, r0, #8
    389c:	428b      	cmp	r3, r1
    389e:	d344      	bcc.n	392a <__udivsi3+0x9e>
    38a0:	0b03      	lsrs	r3, r0, #12
    38a2:	428b      	cmp	r3, r1
    38a4:	d328      	bcc.n	38f8 <__udivsi3+0x6c>
    38a6:	0c03      	lsrs	r3, r0, #16
    38a8:	428b      	cmp	r3, r1
    38aa:	d30d      	bcc.n	38c8 <__udivsi3+0x3c>
    38ac:	22ff      	movs	r2, #255	; 0xff
    38ae:	0209      	lsls	r1, r1, #8
    38b0:	ba12      	rev	r2, r2
    38b2:	0c03      	lsrs	r3, r0, #16
    38b4:	428b      	cmp	r3, r1
    38b6:	d302      	bcc.n	38be <__udivsi3+0x32>
    38b8:	1212      	asrs	r2, r2, #8
    38ba:	0209      	lsls	r1, r1, #8
    38bc:	d065      	beq.n	398a <__udivsi3+0xfe>
    38be:	0b03      	lsrs	r3, r0, #12
    38c0:	428b      	cmp	r3, r1
    38c2:	d319      	bcc.n	38f8 <__udivsi3+0x6c>
    38c4:	e000      	b.n	38c8 <__udivsi3+0x3c>
    38c6:	0a09      	lsrs	r1, r1, #8
    38c8:	0bc3      	lsrs	r3, r0, #15
    38ca:	428b      	cmp	r3, r1
    38cc:	d301      	bcc.n	38d2 <__udivsi3+0x46>
    38ce:	03cb      	lsls	r3, r1, #15
    38d0:	1ac0      	subs	r0, r0, r3
    38d2:	4152      	adcs	r2, r2
    38d4:	0b83      	lsrs	r3, r0, #14
    38d6:	428b      	cmp	r3, r1
    38d8:	d301      	bcc.n	38de <__udivsi3+0x52>
    38da:	038b      	lsls	r3, r1, #14
    38dc:	1ac0      	subs	r0, r0, r3
    38de:	4152      	adcs	r2, r2
    38e0:	0b43      	lsrs	r3, r0, #13
    38e2:	428b      	cmp	r3, r1
    38e4:	d301      	bcc.n	38ea <__udivsi3+0x5e>
    38e6:	034b      	lsls	r3, r1, #13
    38e8:	1ac0      	subs	r0, r0, r3
    38ea:	4152      	adcs	r2, r2
    38ec:	0b03      	lsrs	r3, r0, #12
    38ee:	428b      	cmp	r3, r1
    38f0:	d301      	bcc.n	38f6 <__udivsi3+0x6a>
    38f2:	030b      	lsls	r3, r1, #12
    38f4:	1ac0      	subs	r0, r0, r3
    38f6:	4152      	adcs	r2, r2
    38f8:	0ac3      	lsrs	r3, r0, #11
    38fa:	428b      	cmp	r3, r1
    38fc:	d301      	bcc.n	3902 <__udivsi3+0x76>
    38fe:	02cb      	lsls	r3, r1, #11
    3900:	1ac0      	subs	r0, r0, r3
    3902:	4152      	adcs	r2, r2
    3904:	0a83      	lsrs	r3, r0, #10
    3906:	428b      	cmp	r3, r1
    3908:	d301      	bcc.n	390e <__udivsi3+0x82>
    390a:	028b      	lsls	r3, r1, #10
    390c:	1ac0      	subs	r0, r0, r3
    390e:	4152      	adcs	r2, r2
    3910:	0a43      	lsrs	r3, r0, #9
    3912:	428b      	cmp	r3, r1
    3914:	d301      	bcc.n	391a <__udivsi3+0x8e>
    3916:	024b      	lsls	r3, r1, #9
    3918:	1ac0      	subs	r0, r0, r3
    391a:	4152      	adcs	r2, r2
    391c:	0a03      	lsrs	r3, r0, #8
    391e:	428b      	cmp	r3, r1
    3920:	d301      	bcc.n	3926 <__udivsi3+0x9a>
    3922:	020b      	lsls	r3, r1, #8
    3924:	1ac0      	subs	r0, r0, r3
    3926:	4152      	adcs	r2, r2
    3928:	d2cd      	bcs.n	38c6 <__udivsi3+0x3a>
    392a:	09c3      	lsrs	r3, r0, #7
    392c:	428b      	cmp	r3, r1
    392e:	d301      	bcc.n	3934 <__udivsi3+0xa8>
    3930:	01cb      	lsls	r3, r1, #7
    3932:	1ac0      	subs	r0, r0, r3
    3934:	4152      	adcs	r2, r2
    3936:	0983      	lsrs	r3, r0, #6
    3938:	428b      	cmp	r3, r1
    393a:	d301      	bcc.n	3940 <__udivsi3+0xb4>
    393c:	018b      	lsls	r3, r1, #6
    393e:	1ac0      	subs	r0, r0, r3
    3940:	4152      	adcs	r2, r2
    3942:	0943      	lsrs	r3, r0, #5
    3944:	428b      	cmp	r3, r1
    3946:	d301      	bcc.n	394c <__udivsi3+0xc0>
    3948:	014b      	lsls	r3, r1, #5
    394a:	1ac0      	subs	r0, r0, r3
    394c:	4152      	adcs	r2, r2
    394e:	0903      	lsrs	r3, r0, #4
    3950:	428b      	cmp	r3, r1
    3952:	d301      	bcc.n	3958 <__udivsi3+0xcc>
    3954:	010b      	lsls	r3, r1, #4
    3956:	1ac0      	subs	r0, r0, r3
    3958:	4152      	adcs	r2, r2
    395a:	08c3      	lsrs	r3, r0, #3
    395c:	428b      	cmp	r3, r1
    395e:	d301      	bcc.n	3964 <__udivsi3+0xd8>
    3960:	00cb      	lsls	r3, r1, #3
    3962:	1ac0      	subs	r0, r0, r3
    3964:	4152      	adcs	r2, r2
    3966:	0883      	lsrs	r3, r0, #2
    3968:	428b      	cmp	r3, r1
    396a:	d301      	bcc.n	3970 <__udivsi3+0xe4>
    396c:	008b      	lsls	r3, r1, #2
    396e:	1ac0      	subs	r0, r0, r3
    3970:	4152      	adcs	r2, r2
    3972:	0843      	lsrs	r3, r0, #1
    3974:	428b      	cmp	r3, r1
    3976:	d301      	bcc.n	397c <__udivsi3+0xf0>
    3978:	004b      	lsls	r3, r1, #1
    397a:	1ac0      	subs	r0, r0, r3
    397c:	4152      	adcs	r2, r2
    397e:	1a41      	subs	r1, r0, r1
    3980:	d200      	bcs.n	3984 <__udivsi3+0xf8>
    3982:	4601      	mov	r1, r0
    3984:	4152      	adcs	r2, r2
    3986:	4610      	mov	r0, r2
    3988:	4770      	bx	lr
    398a:	e7ff      	b.n	398c <__udivsi3+0x100>
    398c:	b501      	push	{r0, lr}
    398e:	2000      	movs	r0, #0
    3990:	f000 f806 	bl	39a0 <__aeabi_idiv0>
    3994:	bd02      	pop	{r1, pc}
    3996:	46c0      	nop			; (mov r8, r8)

00003998 <__aeabi_uidivmod>:
    3998:	2900      	cmp	r1, #0
    399a:	d0f7      	beq.n	398c <__udivsi3+0x100>
    399c:	e776      	b.n	388c <__udivsi3>
    399e:	4770      	bx	lr

000039a0 <__aeabi_idiv0>:
    39a0:	4770      	bx	lr
    39a2:	46c0      	nop			; (mov r8, r8)

000039a4 <__libc_init_array>:
    39a4:	b570      	push	{r4, r5, r6, lr}
    39a6:	2600      	movs	r6, #0
    39a8:	4d0c      	ldr	r5, [pc, #48]	; (39dc <__libc_init_array+0x38>)
    39aa:	4c0d      	ldr	r4, [pc, #52]	; (39e0 <__libc_init_array+0x3c>)
    39ac:	1b64      	subs	r4, r4, r5
    39ae:	10a4      	asrs	r4, r4, #2
    39b0:	42a6      	cmp	r6, r4
    39b2:	d109      	bne.n	39c8 <__libc_init_array+0x24>
    39b4:	2600      	movs	r6, #0
    39b6:	f000 f851 	bl	3a5c <_init>
    39ba:	4d0a      	ldr	r5, [pc, #40]	; (39e4 <__libc_init_array+0x40>)
    39bc:	4c0a      	ldr	r4, [pc, #40]	; (39e8 <__libc_init_array+0x44>)
    39be:	1b64      	subs	r4, r4, r5
    39c0:	10a4      	asrs	r4, r4, #2
    39c2:	42a6      	cmp	r6, r4
    39c4:	d105      	bne.n	39d2 <__libc_init_array+0x2e>
    39c6:	bd70      	pop	{r4, r5, r6, pc}
    39c8:	00b3      	lsls	r3, r6, #2
    39ca:	58eb      	ldr	r3, [r5, r3]
    39cc:	4798      	blx	r3
    39ce:	3601      	adds	r6, #1
    39d0:	e7ee      	b.n	39b0 <__libc_init_array+0xc>
    39d2:	00b3      	lsls	r3, r6, #2
    39d4:	58eb      	ldr	r3, [r5, r3]
    39d6:	4798      	blx	r3
    39d8:	3601      	adds	r6, #1
    39da:	e7f2      	b.n	39c2 <__libc_init_array+0x1e>
    39dc:	00003a68 	.word	0x00003a68
    39e0:	00003a68 	.word	0x00003a68
    39e4:	00003a68 	.word	0x00003a68
    39e8:	00003a6c 	.word	0x00003a6c

000039ec <memcpy>:
    39ec:	2300      	movs	r3, #0
    39ee:	b510      	push	{r4, lr}
    39f0:	429a      	cmp	r2, r3
    39f2:	d100      	bne.n	39f6 <memcpy+0xa>
    39f4:	bd10      	pop	{r4, pc}
    39f6:	5ccc      	ldrb	r4, [r1, r3]
    39f8:	54c4      	strb	r4, [r0, r3]
    39fa:	3301      	adds	r3, #1
    39fc:	e7f8      	b.n	39f0 <memcpy+0x4>

000039fe <memset>:
    39fe:	0003      	movs	r3, r0
    3a00:	1882      	adds	r2, r0, r2
    3a02:	4293      	cmp	r3, r2
    3a04:	d100      	bne.n	3a08 <memset+0xa>
    3a06:	4770      	bx	lr
    3a08:	7019      	strb	r1, [r3, #0]
    3a0a:	3301      	adds	r3, #1
    3a0c:	e7f9      	b.n	3a02 <memset+0x4>

00003a0e <strlen>:
    3a0e:	2300      	movs	r3, #0
    3a10:	5cc2      	ldrb	r2, [r0, r3]
    3a12:	3301      	adds	r3, #1
    3a14:	2a00      	cmp	r2, #0
    3a16:	d1fb      	bne.n	3a10 <strlen+0x2>
    3a18:	1e58      	subs	r0, r3, #1
    3a1a:	4770      	bx	lr
    3a1c:	70657453 	.word	0x70657453
    3a20:	206e6168 	.word	0x206e6168
    3a24:	63656c45 	.word	0x63656c45
    3a28:	6e6f7274 	.word	0x6e6f7274
    3a2c:	00736369 	.word	0x00736369
    3a30:	6c6f6f4d 	.word	0x6c6f6f4d
    3a34:	61706974 	.word	0x61706974
    3a38:	4d207373 	.word	0x4d207373
    3a3c:	20696e69 	.word	0x20696e69
    3a40:	00454c42 	.word	0x00454c42
    3a44:	20776152 	.word	0x20776152
    3a48:	00444948 	.word	0x00444948
    3a4c:	6279654b 	.word	0x6279654b
    3a50:	6472616f 	.word	0x6472616f
    3a54:	44494820 	.word	0x44494820
    3a58:	00000000 	.word	0x00000000

00003a5c <_init>:
    3a5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3a5e:	46c0      	nop			; (mov r8, r8)
    3a60:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3a62:	bc08      	pop	{r3}
    3a64:	469e      	mov	lr, r3
    3a66:	4770      	bx	lr

00003a68 <__init_array_start>:
    3a68:	000020dd 	.word	0x000020dd

00003a6c <_fini>:
    3a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3a6e:	46c0      	nop			; (mov r8, r8)
    3a70:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3a72:	bc08      	pop	{r3}
    3a74:	469e      	mov	lr, r3
    3a76:	4770      	bx	lr

00003a78 <__fini_array_start>:
    3a78:	000020b5 	.word	0x000020b5
